#==============================================================================
#
#  $Id$
#
#  MIDI sequencer and data model module.
#
#  Copyright 1999 Michael A. Muller <mmuller@enduden.com>
#  Copyright 2011-2012 Google Inc.
#  Copyright 2012 Conrad Steenberg <conrad.steenberg@gmail.com>
#  
#    This Source Code Form is subject to the terms of the Mozilla Public
#    License, v. 2.0. If a copy of the MPL was not distributed with this
#    file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  
#
#==============================================================================

import crack.ascii hex, radix;
import crack.cont.array Array;
import crack.lang AssertionError, InvalidArgumentError, InvalidStateError, ManagedBuffer;
import crack.io cerr, StandardFormatter, FStr, Formatter, StringFormatter, 
    Reader, Writer;

@import crack.ann assert, interface, implements;

const int
    SNDCTL_SEQ_SYNC = 20737,
    SNDCTL_SEQ_RESET = 20736,
    SNDCTL_TMR_START = 21506,
    SNDCTL_TMR_STOP = 21507,
    SNDCTL_TMR_TIMEBASE = -1073458175,
    SNDCTL_TMR_TEMPO = -1073458171,
    SNDCTL_SEQ_CTRLRATE = -1073458941;

# if this is true, all received midi events will be printed
bool _printEvents;

## Wrapper to help write to a midi stream.  Manages a buffer and allows you to 
## keep track of a status byte.
class MidiWriter {
    Writer out;
    byte status;
    ManagedBuffer buffer = {1024};
    oper init(Writer out) : out = out {}

    ## Write eveything buffered to the final output stream.
    @final void flush() {
        out.write(buffer);
        buffer.size = 0;
    }
    
    @final void write(byte b) {
        if (buffer.size == 1024)
            flush();
        buffer.buffer[buffer.size++] = b;
    }
    
    ## Writes the status byte but only if it is not already the current status.
    @final void writeStatus(byte b) {
        if (status != b) {
            status = b;
            write(b);
        }
    }
    
    @final void encodeVarLen(uint val) {
        if (!val) {
            write(0);
            return;
        }

        # find the high 7 bits
        uint x = val;
        uint shifts;
        while (x) {
            x >>= 7;
            ++shifts;
        }

        while (--shifts)
            write(byte( (val >> (7 * shifts)) & 0x7f | 0x80 ));
        
        # write the last byte
        write(byte(val & 0x7f));
    }
    
    oper del() {
        flush();
    }
}

##  A MIDI event.  An abstract base class.
##  
##  Public variables:
##      time: Absolute time of the event.
@abstract class Event {

    uint time;

    oper init(uint time) : time = time {}

    class StatAndString {
        byte status;
        String rep;
        oper init(byte status, byteptr rep, uintz size) :
            status = status, 
            rep(rep, size, true)  {
        }
        
        oper init(byte status, String rep) : status = status, rep = rep {}
    }

    ## Used to convert the event to a string of bytes suitable for inclusion
    ## in a midi stream of some sort.  /status/ is the current, running
    ## status byte.
    ## 
    ## This method returns a tuple consisting of the new status byte and
    ## the string representation of the event.
    @abstract StatAndString toMidiString(byte status);
    
    @abstract void writeTo(MidiWriter writer);
    
    ## Make a copy of the event object.
    @abstract Event clone();
}

## Abstract base class for all events that apply to a particular channel.
## 
## Public variables:
##  channel: The channel that the event occurred on.  An integer from 0-15.
@abstract class ChannelEvent : Event {
    byte channel;

    oper init(uint time, byte channel) : Event(time), channel = channel {}
}

##  Base class for midi "note on" and "note off" events, both of which have
##  the same public interface.
##  
##  Public variables:
##  note: Numeric note (0-127)
##  velocity: Numeric velocity (0-127)
@abstract class NoteEvent : ChannelEvent {
   
   byte note, velocity;
   oper init(uint time, byte channel, byte note, byte velocity) :
        ChannelEvent(time, channel),
        note = note,
        velocity = velocity {
    }
}

## Midi "note on" event.
class NoteOn : NoteEvent {

    oper init(uint time, byte channel, byte note, byte velocity) :
        NoteEvent(time, channel, note, velocity) {
    }
   
    StatAndString toMidiString(byte status) {
        if (status == (0x90 | channel)) {
            return StatAndString(status, byteptr![note, velocity], 2);
        } else {
            status = 0x90 | channel;
            return StatAndString(status, byteptr![status, note, velocity], 3);
        }
    }
    
    Event clone() {
        return NoteOn(time, channel, note, velocity);
    }
    
    void writeTo(MidiWriter out) {
        out.writeStatus(0x90 | channel);
        out.write(note);
        out.write(velocity);
    }
    
    void formatTo(Formatter f) {
        f `ch: $channel, note $note on, velocity $velocity`;
    }
}

##  Midi "note off" event.
##  
##  This may be in conflict with the actual midi spec, but I am assuming
##  that only a note off with a velocity of 0 can be used in a running
##  "note on" status (as a "note on" event with a velocity of 0).  Any
##  other velocity value will result in a change in the current status
##  to "note off" so that the velocity can be reflected.
class NoteOff : NoteEvent {

    oper init(uint time, byte channel, byte note, byte velocity) :
        NoteEvent(time, channel, note, velocity) {
    }
   
    StatAndString toMidiString(byte status) {
        if (status == (0x80 | channel)) {
            return StatAndString(status, byteptr![note, velocity], 2);
        } else if (status == (0x90 | channel) && velocity == 0) {
            return StatAndString(status, byteptr![note, 0], 2);
        } else {
            status = 0x80 | channel;
            return StatAndString(status, byteptr![status, note, velocity], 3);
        }
    }
    
    void writeTo(MidiWriter out) {
        # handle the "note on" status specially - if we're in note on, and the
        # velocity is 0 (which it should always be) we can just emit note on 
        # with velocity zero.
        if (out.status != (0x90 | channel) || velocity) 
            out.writeStatus(0x80 | channel);
        out.write(note);
        out.write(velocity);
    }
    
    Event clone() {
        return NoteOff(time, channel, note, velocity);
    }

    void formatTo(Formatter f) {
        f `ch: $channel, note $note off, velocity $velocity`;
    }
}

##  Midi "program change" event.
##
##  Public variables:
##  /program/::
##     New program number (0-127).
class ProgramChange : ChannelEvent {

    byte program;

    oper init(uint time, byte channel, byte program) :
        ChannelEvent(time, channel),
        program = program {
    }

    StatAndString toMidiString(byte status) {   
        # since there is no reason to do running program changes on the same
        # channel, we just always send a status byte.
        status = 0xC0 | channel;
        return StatAndString(status, byteptr![status, program], 2);
    }
    
    void writeTo(MidiWriter out) {
        out.writeStatus(0xC0 | channel);
        out.write(program);
    }
    
    Event clone() {
        return ProgramChange(time, channel, program);
    }
    
    void formatTo(Formatter f) {
        f `ch: $channel, change to program $program`;
    }
}

##  Midi "pitch wheel" event.
##  
##  Public variables:
##  /value/::
##     Numeric value of the pitch wheel.  A value of 0x2000 is centered.
##     Higher values transpose the pitch up, lower values transpose it down.
##
class PitchWheel : ChannelEvent {

    int value;
    oper init(uint time, byte channel, int value) :
        ChannelEvent(time, channel),
        value = value {
    }

    StatAndString toMidiString(byte status) {
        if (status == (0xE0 | channel)) {
            return StatAndString(status, 
                                 byteptr![byte(value & 0x7F), byte(value >> 7)], 
                                 2
                                 );
        } else {
            status = 0xE0 | channel;
            return StatAndString(status,
                                 byteptr![
                                    status, 
                                    byte(value & 0x7F), 
                                    byte(value >> 7)
                                 ],
                                 3
                                 );
        }
    }
    
    void writeTo(MidiWriter out) {
        out.writeStatus(0xE0 | channel);
        out.write(byte(value & 0x7F));
        out.write(byte(value >> 7 & 0xFF));
    }
    
    Event clone() {
        return PitchWheel(time, channel, value);
    }

    void formatTo(Formatter f) {
        f `ch: $channel, pitch wheel to $value`;
    }
}

##  Midi "control change" event.
##  
##  Public variables:
##  /controller/::
##     The controller in question.
##  /value/::
##     The new value for the controller.
class ControlChange : ChannelEvent {
    byte controller, value;
    
    oper init(uint time, byte channel, byte controller, byte value) :
        ChannelEvent(time, channel),
        controller = controller,
        value = value {
    }

    StatAndString toMidiString(byte status) {
        if (status == (0xB0 | channel)) {
            return StatAndString(status, byteptr![controller, value], 2);
        } else {
            status = 0xB0 | channel;
            return StatAndString(status, byteptr![status, controller, value],
                                 3
                                 );
        }
    }
    
    void writeTo(MidiWriter out) {
        out.writeStatus(0xB0 | channel);
        out.write(controller);
        out.write(value);
    }
    
    Event clone() {
        return ControlChange(time, channel, controller, value);
    }

    void formatTo(Formatter f) {
        f `ch: $channel, control $controller changed to $value`;
    }
}

##  Midi "system exclusive" event.  Just a big bag of data passed into
##  the system.
##  
##  Public Variables:
##  data: A string of binary data to be passed into the remote system. 
##     The leading F0 and trailing F7 bytes should be omitted: they will
##     be generated by the @asMidiString() method.
class SysEx : Event {

    String data;

    oper init(uint time, String data) : Event(time), data = data {}

    StatAndString toMidiString(byte status) {
        StringFormatter temp = {};
        temp `\xF0$data\xF7`;
        return StatAndString(0xF0, temp.string());
    }
    
    Event clone() {
        return SysEx(time, data);
    }

    void writeTo(MidiWriter out) {
        out.writeStatus(0xF0);
        out.encodeVarLen(data.size + 1);
        for (uintz i = 0; i < data.size; ++i)
            out.write(data[i]);
        out.write(0xF7);
    }
    
    void formatTo(Formatter f) {
        f `SysEx: `;
        for (uintz i = 0; i < data.size; ++i)
            f `$(radix(data[i], 16))`;
    }
}

## Pseudo-event used as a marker for the end of the track.
## When a track is deserialized, the EndTrack is automatically added from the 
## end track marker in the stream.  When a track is serialized, if it doesn't 
## have an EndTrack event one will be written at the time of the last existing 
## event on the track.
class EndTrack : Event {
    oper init(uint time) : Event(time) {}

    typeof(EndTrack(0).toMidiString(0)) toMidiString(byte status) {
        return null;
    }
    
    void writeTo(MidiWriter out) {
        out.write(0xFF);
        out.write(0x2F);
        out.write(0);
    }

    Event clone() {
        return EndTrack(time);
    }
    
    void formatTo(Formatter f) {
        f `EndEvent`;
    }
}

# XXX Still need the following classes:
#     AfterTouch
#     ChannelPressure
#     RealTime

## Abstract base class for all event sources.  Implements the iterator 
## protocol.
@abstract class EventSource {
    @abstract void next();
    @abstract Event elem();
}

##  Abstrack class for event sources that are random access: allowing
##  the user to define the position within the event stream as a midi
##  clock.
@abstract class SeekableEventSource : EventSource {

    ## Sets the position within the event stream.  /pos/ is an
    ## absolute midi clock value.
    @abstract void setPos(uint pos);
   
    ## Returns the position within the event stream as an absolute value.
    @abstract uint getPos();
 
    ## Returns the position of the last event in the event stream.  
    @abstract uint getEnd();
}

##  A *Track* is a list of events, sorted in order of their time.
##  
##  Public variables:
##  name:
##     Every track can have an associated name.  If the tracks is part of
##     a "piece", use Piece.renameTrack() to rename the track instead
##     of setting this attribute directly.
##     
##     A track name must be unique within the piece.
class Track {
   
    String name;
    Array[Event] __events;

    class TrackEventSource : SeekableEventSource {
        Array[Event] __events;
        uint __i;
        oper init(Array[Event] events, uint i) :
            __events = events,
            __i = i {
        }
        bool isTrue() { return __i < __events.count(); }
        void next() { ++__i; }
        Event elem() { return __events[__i]; }
        
        void setPos(uint pos) {
            uint binsearch(Array[Event] events, uint bottom, uint top,
                           uint target) {
                if (target <= events[bottom].time)
                    return bottom;
                else if (bottom - top == 1)
                    return top;
                
                mid := bottom + (top - bottom) / 2;
                if (target < events[mid].time)
                    return binsearch(events, bottom, mid, target);
                else
                    return binsearch(events, mid, top, target);
            }
            
            # rule out some simple conditions
            if (!__events || pos <= __events[0].time)
                __i = 0;
            else if (pos > __events[-1].time)
                __i =  __events.count();
            
            __i = binsearch(__events, 0, __events.count(), pos);
        }
        
        uint getPos() {
            if (__i < __events.count())
                return __events[__i].time;
            else if (!__events)
                return 0;
            else
                return __events[-1].time + 1;
        }
        
        uint getEnd() {
            if (__events)
                return __events[-1].time;
            else
                return 0;
        }
    }
    
    oper init(String name, Array[Event] events) :
        name = name,
        __events = events {
    }
    
    oper init(String name) : name = name, __events() {}

    ## Add the event to the track at the correct location (with respect to the 
    ## time of the other events).
    void add(Event event) {
        if (!__events) {
            __events.append(event);
        } else if (event.time >= __events[-1].time) {
            __events.append(event);
        } else {
            for (evtCur :on __events) {
                evt := evtCur.elem();
                if (evt.time > event.time) {
                    __events.insert(evtCur, event);
                    return;
                }
            }
            
            throw AssertionError('found no location to insert an event');
        }
    }
    
    ## Adds a new event to the end of the track.  The time of the event must 
    ## be later than or equal to the time of the last event in the track, 
    ## otherwise this throws InvalidArgumentError.
    void append(Event evt) {
        if (__events && evt.time < __events[-1].time)
            throw InvalidArgumentError(FStr() 
                                       I`Appending event $evt which is earlier \
                                         than the last event of the track \
                                         ($(__events[-1].time)).`
                                       );
        __events.append(evt);
    }

    Event oper [](int index) {
        return __events[index];
    }
    
    uint count() { return __events.count(); }
    
    TrackEventSource iter() { return TrackEventSource(__events, 0); }

    ## write all of the events in the track with their time deltas.
    void writeEvents(MidiWriter out) {
        uint lastTime = 0;
        for (event :in this) {
            out.encodeVarLen(event.time - lastTime);
            event.writeTo(out);
            lastTime = event.time;
        }
    }
    
    void writeTo(MidiWriter out) {
        writeEvents(out);
        out.write(0);  # time from last event.
        out.write(0xff);
        out.write(0x2f);
        out.write(0);
    }
    
    void formatTo(Formatter out) {
        for (event :in this)
            out `$(event.time): $event\n`;
    }

/*   
   def merge(self, other):
      """
         Returns a new track consisting of the events of /self/ and /other/
         combined.
      """
      source = TrackZipper( [self, other] )
      return Track(self.name, source.getEvents())

   def overwrite(self, other):
      """
         Returns a new track which is the current track overwritten with
         other using a @TrackOverwriter.
      """
      source = TrackOverwriter( [self, other] )
      return Track(self.name, source.getEvents())

   def getChannel(self):
      """
         Returns the channel of the first channel event on the track.
         If there are no channel events on the track, returns *None*.
      """
      for evt in self.__events:
         if isinstance(evt, ChannelEvent):
            return evt.channel
      return None
*/
}

Track merge(String name, Array[Track] tracks) {
    alias Iter = typeof(tracks[0].iter());

    # build an array of iterators
    Array[Iter] iters = {tracks.count()};
    for (t :in tracks)
        iters.append(t.iter());
    
    Track result = {name};

    # repeat until there are no more events in any of the iterators        
    while (iters) {
        
        # find the earliest event in all of the iterators
        Event first;
        int firstIndex;
        int index;
        for (iter :in iters) {
            if (!first || iter.elem().time < first.time) {
                first = iter.elem();
                firstIndex = index;
            }
            
            ++index;
        }

        # bump the iterator for the next event forward
        iters[firstIndex].next();
        if (!iters[firstIndex])
            iters.delete(firstIndex);

        result.append(first);
    }
    
    return result;
}

const BUF_SIZE := 1024;

class MidiReader {
    byte status;
    Reader src;
    ManagedBuffer buf = {BUF_SIZE};
    uint pos;
    
    oper init(Reader src) : src = src {}
    
    @final void needByte() {
        if (pos == buf.size) {
            src.read(buf);
            if (!buf.size)
                throw InvalidStateError('Out of data reading midi file');
            pos = 0;
        }
    }
    
    @final byte readByte() {
        needByte();
        return buf.buffer[pos++];
    }
    
    uint readVarLen() {
        uint val;
        byte b = 0x80;
        while (b & 0x80) {
            b = readByte();
            val = val << 7 | (b & 0x7F);
        }
        return val;
    }
    
    ## This gets called when we read an event with an unknown status byte.  
    ## Override it to deal with special events.
    Event readUserEvent() {
        @assert(false);
        return null;
    }
    
    @final Event readEvent() {
        byte first = readByte();
        
        # is it a status byte?
        if (first & 0x80) {
            status = first;
            first = readByte();
        }

        statusHigh := status & 0xF0;
        channel := status & 0xF;
        if (statusHigh == 0x90) {
            velocity := readByte();
            if (velocity)
                return NoteOn(0, channel, first, velocity);
            else
                return NoteOff(0, channel, first, velocity);
        } else if (statusHigh == 0x80) {
            return NoteOff(0, channel, first, readByte());
        } else if (statusHigh == 0xE0) {
            high := readByte();
            return PitchWheel(0, channel, (readByte() << 7) | first);
        } else if (statusHigh == 0xC0) {
            return ProgramChange(0, channel, first);
        } else if (statusHigh == 0xB0) {
            return ControlChange(0, channel, first, readByte());
        } else if (status == 0xF0) {
            # sys-ex event
            size := readVarLen();
            ManagedBuffer tempBuf = {size};
            # XXX broken! Will ignore the existing buffer.
            src.read(tempBuf);
            terminator := readByte();
            @assert(terminator == 0xF7);
            return SysEx(0, String(tempBuf, true));
        } else if (status == 0xFF) {
            action := first;
            if (action == 0x2F) {
                @assert(readByte() == 0);
                return EndTrack(0);
            } else {
                return null;
            }
        } else {
            return readUserEvent();
        }
    }
    
    Track readTrack(String name) {
        Track track = {name};
        uint t;
        while (true) {
            # read the time
            t += readVarLen();
            evt := readEvent();
            if (!evt)
                break;
            evt.time = t;
            track.add(evt);
            if (evt.isa(EndTrack))
                break;
        }
        
        return track;
    }
}

/*
   def __init__(self, tracks):
      self._events = []
      tracks = map(TrackCursor, tracks)
      event = 1
      
      # build an ordered list of the events in each of the tracks
      while event:
      
         # find the track with the next available event
         event = None
         for track in tracks:
            if track.hasMoreEvents():
               if not event:
                  bestTrack = track
                  event = track.peekNextEvent()
                  continue
                  
               trackEvent = track.peekNextEvent()
               if trackEvent.time < event.time:
                  bestTrack = track
                  event = trackEvent
         
         if event:
            self._addEvent(event, bestTrack, tracks)
            bestTrack.nextEvent()
      
      self.__index = 0
      self.__pos = 0

   def _addEvent(self, event, track, tracks):
      self._events.append(event)
   
   def hasMoreEvents(self):
      return self.__index < len(self._events)
   
   def nextEvent(self):
      if self.__index < len(self._events):
         evt = self._events[self.__index]
         self.__index = self.__index + 1
         try:
            self.__pos = self._events[self.__index].time
         except IndexError:
            self.__pos = evt.time + 1
         return evt
      else:
         return None
   
   def peekNextEvent(self):
      if self._events:
         return self._events[0]
      else:
         return None

   def getEvents(self):
      """
         Returns the entire event list - this is the original, so changing
         it changes the instance.
      """
      return self._events
   
   def getPos(self):
      return self.__pos
   
   def setPos(self, pos):
      self.__pos = pos
      
      # if there are no events, this is not an issue
      if not self._events:
         self.__index = 1
         return
      
      # see if it is later than the last event
      if pos > self._events[-1].time:
         self.__index = len(self._events)
         print 'pos is %d, index past the end (%d)' % \
            (pos, self._events[-1].time)
         return
      
      # look for it
      for i in range(len(self._events)):
         if pos <= self._events[i].time:
            self.__index = i
            print 'setting index to %d' % i
            break
      else:
         # should never get here
         assert 0 

   def getEnd(self):
      return self._events[-1].time

class TrackOverwriter(TrackZipper):

   """
      This currently implements a "clean-cut" overwriter.  Given a list of two
      tracks, removes all events from the first track which occur during the
      "period of activity" of the second track.  Any NoteOn events which
      are left dangling are turned off at the beginning of this period, 
      any NoteOn events which occur during the period that are not turned off
      during the period are turned on at the end of the period.
   """
   
   def __init__(self, tracks):
      assert len(tracks) == 2
      self.__map = [None] * 128
      self.__done = 0
      TrackZipper.__init__(self, tracks)
   
   def __mapEvent(self, event):
      # store the index of the event that turned them on.
      if isinstance(event, NoteOn):
         self.__map[event.note] = (len(self._events), event.velocity)
         print 'mapping note on: %d, %d' % (event.time, event.note)
      elif isinstance(event, NoteOff):
         self.__map[event.note] = None
         print 'mapping note off: %d, %d' % (event.time, event.note)
   
   def _addEvent(self, event, track, tracks):
      if track is tracks[0]:
         # keep track of which notes are on and which notes are off,
         self.__mapEvent(event)
         self._events.append(event)
      elif not self.__done:
         # turn off all notes that are currently "on"
         for i in range(len(self.__map)):
            if self.__map[i] is not None:
               self._events.append(NoteOff(event.time, event.channel, i, 0))
               print 'truncating %d' % i
               self.__map[i] = None
         
         # add the new event
         self._events.append(event)
         
         # walk through all events on the first track that occur before the
         # end of the second track, build a map so that we'll know what to
         # turn off.
         
         endTime = track.getTrack()[-1].time
         print 'end time %d' % endTime
         firstTrack = tracks[0]
         while firstTrack.hasMoreEvents():
            e = firstTrack.peekNextEvent()
            if e.time > endTime:
               break
            else:
               self.__mapEvent(e)
               firstTrack.nextEvent()

         # add all of the rest of the events for the track
         while track.hasMoreEvents():
            e = track.nextEvent()
            self._events.append(e)
         
         # turn on all notes that are going to be turned off          
         for i in range(len(self.__map)):
            if self.__map[i] is not None:
               print 'starting %d' % i
               self._events.append(NoteOn(endTime, event.channel, i,
                                          self.__map[i][1]
                                          )
                                   )        
         

class TrackCursor(SeekableEventSource):
   """
      A *TrackCursor* is the means by which we iterate over the set of events
      in a track.
   """

   def __init__(self, track):
      EventSource.__init__(self)
      self.__track = track
      self.__index = 0
      self.__pos = 0

   def hasMoreEvents(self):
      return self.__index < len(self.__track)

   def nextEvent(self):
      event = self.peekNextEvent()
      self.__index = self.__index + 1
      if event:
         self.__pos = event.time
      else:
         self.__pos = self.__track[-1].time + 1
      return event      
   
   def peekNextEvent(self):
      try:
         return self.__track[self.__index]
      except IndexError:
         return None      

   def getTrack(self):
      """
         Returns the associated track.
      """
      return self.__track
   
   def getPos(self):
      return self.__pos
   
   def setPos(self, pos):
      self.__pos = pos
      if pos > self.__track[-1].time:
         self.__index = len(self.__track)
      else:
         for index in range(len(self.__track)):
            if pos <= self.__track[index].time:
               self.__index = index
               break
         else:
            assert 0 # should never get here

   def getEnd(self):
      return self.__track[-1].time   

class Piece:

   """
      A *Piece* is a collection of tracks.
   """
   
   def __init__(self):
      self.__tracks = {}

   def addTrack(self, track):
      self.__tracks[track.name] = track
   
   def getTracks(self):
      return self.__tracks.values()

   def getTrack(self, trackName):
      return self.__tracks[trackName]

   def deleteTrack(self, track):
      """
         Deletes a track from the piece.  /track/ can be either a @Track
         instance or the name of a track.
      """
      if isinstance(track, Track):
         track = track.name
      del self.__tracks[track]

class PieceCursor(TrackZipper):
   
   def __init__(self, piece):
      TrackZipper.__init__(self, piece.getTracks())

class StreamReader:
   """
      Maintains state information for the parsing of midi commands out of
      the sequencer or a midi file.
   """

   # statuses
   NO_STATE = 0
   NOTE_ON = 1
   NOTE_OFF = 2
   SYS_EX = 3
   AFTER_TOUCH = 4
   PROGRAM_CHANGE = 5
   CHANNEL_PRESSURE = 6
   PITCH_WHEEL = 7
   CONTROL_CHANGE = 8

   def __init__(self):
      self.__buf = []
      self.__state = self.NO_STATE
      self.__channel = 0
      
      # list of events being input
      self._inputEvents = []

      # the event filter
      self.__eventFilter = None

   def _processCmd(self, time, cmd):
      evt = None
      if cmd & 0x80:
         highNyb = cmd & 0xF0
         if highNyb == 0x80:
            self.__state = self.NOTE_OFF
         elif highNyb == 0x90:
            self.__state = self.NOTE_ON
         elif highNyb == 0xA0:
            self.__state = self.AFTER_TOUCH
         elif highNyb == 0xB0:
            self.__state = self.CONTROL_CHANGE
         elif highNyb == 0xC0:
            self.__state = self.PROGRAM_CHANGE
         elif highNyb == 0xD0:
            self.__state = self.CHANNEL_PRESSURE
         elif highNyb == 0xE0:
            self.__state = self.PITCH_WHEEL
         elif cmd == 0xF0:
            self.__state = self.SYS_EX
            self.__buf = ''
         elif cmd == 0xF7:
            evt = SysEx(time, self.__buf)
            self.__buf = []
         
         # change the channel if the status byte has channel information in
         # it
         if highNyb != 0xF0:
            self.__channel = cmd & 0xF
      else:
         if self.__state == self.NOTE_ON:
            if self.__buf:
               if cmd == 0:
                  evt = NoteOff(time, self.__channel, self.__buf[0], 0)
               else:
                  evt = NoteOn(time, self.__channel, self.__buf[0], cmd)
               self.__buf = []
            else:
               self.__buf.append(cmd)
         elif self.__state == self.NOTE_OFF:
            if self.__buf:
               if cmd == 0:
                  evt = NoteOff(time, self.__channel, self.__buf[0], 0)
               else:
                  evt = NoteOn(time, self.__channel, self.__buf[0], cmd)
               self.__buf = []
            else:
               self.__buf.append(cmd)
         elif self.__state == self.PROGRAM_CHANGE:
            evt = ProgramChange(time, self.__channel, cmd)
         elif self.__state == self.PITCH_WHEEL:
            if self.__buf:
               val = self.__buf[0] | (cmd << 7)
               evt = PitchWheel(time, self.__channel, val)
               self.__buf = []
            else:
               self.__buf.append(cmd)
         elif self.__state == self.CONTROL_CHANGE:
            if self.__buf:
               cntrl = self.__buf[0]
               evt = ControlChange(time, self.__channel, cntrl, cmd)
               self.__buf = []
            else:
               self.__buf.append(cmd)
         elif self.__state == self.SYS_EX:
            self.__buf = self.__buf + chr(cmd)
         else:
            # XXX this should effectively ignore everything else
            pass

      if evt:
         self._eventRead(evt)

      if evt and self.__eventFilter:
         oldEvt = evt
         evt = self.__eventFilter(evt)
         if not evt:
            print 'event filtered:', oldEvt
         
      if evt:
         self._inputEvents.append(evt)

   def setEventFilter(self, filter):
      """
         Sets the object or function that is used to translate and filter
	 events that are read from the midi stream.
         
         /filter/ should be a callable object that accepts an @Event
         as a parameter.

         It should return the same event, or a translated event, or *None*
         if the event is to be discarded.
      """
      self.__eventFilter = filter

   def _eventRead(self, event):
      """
         This is a hook that can be used by derived classes to receive
         notification of when a complete event is read.
      """
      pass

class Sequencer(EventSource, StreamReader):
   
   """
      Wrapper class around /dev/sequencer.
   """
   
   
   def __init__(self, device = '/dev/sequencer'):
      StreamReader.__init__(self)
      self.__src = os.open(device, os.O_RDWR | os.O_NONBLOCK, 0)
      
      # the last status byte written
      self.__status = 0
      
      # this is the queue where we store raw data chunks that are ready to
      # be written to the sequencer.
      self.__outputQueue = []
      
      # this is the current source of output events
      self.__outputEvents = None
      
      self.__timeOffset = 0
      
   def __del__(self):
      os.close(self.__src)

   def hasMoreEvents(self):
      pass
      
   def nextEvent(self):
      pass
   
   def peekNextEvent(self):
      pass

   def record(self, control):
      if hasattr(self, '__firstTimeThrough'):
         self.__reset()
      else:
         self.__firstTimeThrough = 1
      self.__resetTime()
      self.__recordOnly(control)

      track = Track(events = self._inputEvents)
      self._inputEvents = []
      return track

   def __playAndRecord(self, control):
      eventSource = self.__outputEvents
      self.__reset()
      if isinstance(eventSource, SeekableEventSource):
         self.__resetTime(eventSource.getPos())
      else:
         self.__resetTime()
      while 1:
         selected = select([self.__src, control], [self.__src], [])
         
         # first check for incoming events
         if self.__src in selected[0]:
            time, cmd = self.__read()
            self._processCmd(time, cmd)
         
         # check to see if the sequencer is ready to accept more events
         elif (self.__outputQueue or eventSource.hasMoreEvents()) \
              and self.__src in selected[1]:
            self.__writeSeqEvent()
#            self.__writeEvent(eventSource.nextEvent())
         
         # otherwise, this is an event from the controller or we have
         # run out of output events
         else:
            if isinstance(eventSource, SeekableEventSource):
               eventSource.setPos(self.__getPos())
            break
      
      # if we terminated with an event from the controller, reset the
      # sequencer
      if control in selected[0]:
         print 'resetting'
         self.__reset()
         return 0
      else:
         print selected
         return 1

   def playAndRecord(self, eventSource, control):
      self.__outputEvents = eventSource
      if self.__playAndRecord(control):
         # read any remaining events in the input queue
         self.__recordOnly(control)
      
      track = Track(events = self._inputEvents)
      self._inputEvents = []
      return track

   def __writeSeqEvent(self):
      if not self.__outputQueue:
         self.__queueEvent()

      if _printEvents:
         print '%02x %02x %02x %02x' % \
            struct.unpack('BBBB', self.__outputQueue[0])
      
      os.write(self.__src, self.__outputQueue[0])
      del self.__outputQueue[0]
   
   def __queueEvent(self):
      event = self.__outputEvents.nextEvent()
      self.__status, data = event.asMidiString(self.__status)

      time = self.__fixTime(event.time)
      seqEvt = struct.pack('=BHB', 2, time & 0xFFFF,
                           event.time >> 16
                           )
      self.__outputQueue.append(seqEvt)
      
      for cmd in data:
         seqEvt = struct.pack('=BBh', 5, ord(cmd), 0)
         self.__outputQueue.append(seqEvt)

   def play(self, eventSource, control = None):
      self.__outputEvents = eventSource
      if isinstance(eventSource, SeekableEventSource):
         self.__resetTime(eventSource.getPos())
      else:
         self.__resetTime()
      
      if control is not None:
         inputs = [ control ]
      else:
         inputs = []

      self.__outputEvents = eventSource
      eventsWritten = 0
      while 1:
         selected = select(inputs, [self.__src], [])
         
         # check to see if we got an interrupt
         if control is not None and control in selected[0]:
            if isinstance(eventSource, SeekableEventSource):
               eventSource.setPos(self.__getPos())
            self.__reset()
            break
         
         # check to see if the sequencer is ready to accept more events
         elif (self.__outputQueue or eventSource.hasMoreEvents()) \
              and self.__src in selected[1]:
            eventsWritten = eventsWritten + 1
            self.__writeSeqEvent()
         else:
            break
      
      if control is not None:
         self.__syncOrSwim(control)   
      else:
         self.__sync()
         
      print 'events written: %d has more: %d' % (eventsWritten, eventSource.hasMoreEvents())
   
   def __recordOnly(self, control):
      """
         Records events without playing any.
      """
      while 1:
         selected = select([self.__src, control], [], [])
         if self.__src in selected[0]:
            time, cmd = self.__read()
            self._processCmd(time, cmd)
         else:
            self.__reset()
            break

   def __writeEvent(self, event):
      """
         Writes the /event/ to the sequencer.
      """
      self.__status, data = event.asMidiString(self.__status)
      time = self.__fixTime(event.time)
      for cmd in data:
         seqEvt = struct.pack('=BHBBBh',
                              2,
                              time & 0xFFFF,
                              time >> 16,
                              5,
                              ord(cmd),
                              0
                              )
         assert len(seqEvt) == 8
         os.write(self.__src, seqEvt)

   def __read(self):
      """
         Reads the next 8 byte /dev/sequencer event, returns a tuple 
         consisting of timestamp and command ("command" is really just the
         next byte from the midi event stream).
      """
      data = os.read(self.__src, 8)
      code, time, timeHigh, five, cmd, zeroes = struct.unpack('=bHBBBh', data)
      time = self.__fixInputTime(time + (timeHigh << 16))
      return time, cmd
      
   def __reopen(self):
      # XXX not sure if we need this - keeping it around because it's
      # XXX useful for now
      os.close(self.__src)
      self.__src = os.open('/dev/sequencer', os.O_RDWR | os.O_NONBLOCK, 0)

   def __fixTime(self, time):
      return time - self.__timeOffset

   def __fixInputTime(self, time):
      return time + self.__timeOffset

   def __reset(self):
      fcntl.ioctl(self.__src, SNDCTL_SEQ_RESET)
      self.__status = 0

   def __sync(self):
      # write an "ECHO" command (the 8) to the sequencer, then wait for
      # the response (another "ECHO" which will show up when the sequencer
      # is done playing).
      os.write(self.__src, struct.pack('=BHB', 8, 0, 0))
      select([self.__src], [], [])
      data = os.read(self.__src, 4)
      if _printEvents:
         print '%02x %02x %02x %02x' % \
            struct.unpack('BBBB', data)

   def __syncOrSwim(self, control):
      # like the sync, but uses a control stream also, doing a reset if
      # input comes from control.
      # XXX this should fail if any other event comes in before the sync,
      #     but it doesn't seem to.
      os.write(self.__src, struct.pack('=BHB', 8, 0, 0))
      selected = select([self.__src, control], [], [])
      if control in selected[0]:
         self.__reset()
      else:
         data = os.read(self.__src, 4)
         if _printEvents:
            print '%02x %02x %02x %02x' % \
               struct.unpack('BBBB', data)

   def __resetTime(self, time = 0):
      self.__timeOffset = time
      os.write(self.__src, struct.pack('=BHB', 4, 0, 0))
      self.__systemStartTime = os.times()[4]
   
   def __getPos(self):
      return int((os.times()[4] - self.__systemStartTime) * 100) + \
         self.__timeOffset
   
   def showTimeBase(self):
      timebase = struct.pack('i', 200)
      data = fcntl.ioctl(self.__src, SNDCTL_SEQ_CTRLRATE, timebase)
      print 'timebase:', struct.unpack('i', timebase), struct.unpack('i', data)

'''         
import sys
seq = Sequencer()
print 'recording track1'
track1 = seq.record(sys.stdin)
track1.name = 'track 1'
sys.stdin.readline()

print 'playing track 1'
seq.play(TrackCursor(track1))

print 'playing piece'
piece = Piece()
piece.addTrack(track1)
seq.play(PieceCursor(piece))
sys.exit(0)

print 'recording track2'
track2 = seq.playAndRecord(TrackCursor(track1), sys.stdin)
track2.name = 'track 2'
sys.stdin.readline()

piece = Piece()
piece.addTrack(track1)
piece.addTrack(track2)

#print 'test run'
#seq.playAndRecord(PieceCursor(piece), sys.stdin)
#sys.stdin.readline()

print 'playing both'
seq.play(PieceCursor(piece))


"""
   There seems to be something wrong with the PieceCursor.
"""
'''
*/
