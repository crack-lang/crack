# Copyright 2011-2012 Google Inc.
# Copyright 2012 Conrad Steenberg <conrad.steenberg@gmail.com>
# 
#   This Source Code Form is subject to the terms of the Mozilla Public
#   License, v. 2.0. If a copy of the MPL was not distributed with this
#   file, You can obtain one at http://mozilla.org/MPL/2.0/.
# 
# minimal serialization system

import crack.runtime free;
import crack.lang AppendBuffer, Buffer, CString, Exception, ManagedBuffer, 
    WriteBuffer, Formatter;
import crack.io cout, Reader, Writer, StandardFormatter;

const BUFSIZE := uint(1024);
const uint END = ~0;

class BufferDeserializer : Buffer {
    
    # If an external buffer is provided, this variable keeps it in existence.
    Buffer __rep;
    
    # buffer and position.
    uint pos;
    
    # Set to true if the last read succeeded, false if not.
    bool success;
    
    # The last value read.
    uint lastUInt;
    CString lastString;
    float32 lastFloat32;
    float64 lastFloat64;
    
    oper init(Buffer buffer) : 
        Buffer(buffer.buffer, buffer.size), 
        __rep = buffer {
    }
    oper init(Buffer buffer, uint pos) : 
        Buffer(buffer.buffer, buffer.size), 
        __rep = buffer,
        pos = pos {
    }

    oper init(byteptr buffer, uintz size) : Buffer(buffer, size) {}
    
    void reset(Buffer newBuffer) {
        buffer = newBuffer.buffer;
        size = newBuffer.size;
        __rep = newBuffer;
        pos = 0;
    }

    void reset(Buffer newBuffer, uint newPos) {
        buffer = newBuffer.buffer;
        size = newBuffer.size;
        __rep = newBuffer;
        pos = newPos;
    }
    
    void reset(byteptr newBuffer, uintz newSize) {
        buffer = newBuffer;
        size = newSize;
        pos = 0;
    }
    
    BufferDeserializer readUInt() {
        uint cur = pos;
        byte b = 0x80;
        uint val;
        uint offset;
        while (b & 0x80) {
            # make sure we've got data
            if (cur == size) {
                success = false;
                return this;
            }

            # see if we've got the last byte
            b = buffer[cur++];
            val = val | ((b & 0x7f) << offset);
            offset += 7;
        }

        lastUInt = val;
        pos = cur;
        success = true;
        return this;
    }

    BufferDeserializer readString() {
        uint start = pos;
        if (!readUInt().success)
            return this;
        uintz stringSize = lastUInt;
        
        # see if we've got enough space in the buffer.
        if (size - pos >= stringSize) {
            lastString = CString(buffer + pos, stringSize, false);
            pos += stringSize;
        } else {
            # revert pos (since readUInt modified it)
            pos = start;
            success = false;
        }
        return this;
    }

    BufferDeserializer readFloat32() {
        if (success = (size - pos >= 4)) {
            lastFloat32 = array[float32](buffer + pos)[0];
            pos += 4;
        }
        return this;
    }

    BufferDeserializer readFloat64() {
        if (success = (size - pos >= 8)) {
            lastFloat64 = array[float64](buffer + pos)[0];
            pos += 8;
        }
        return this;
    }
    
    ## returns the number of bytes available in the buffer.
    uint getAvailable() {
        return size - pos;
    }
}

class SerialReader {
    
    Reader __src;
    ManagedBuffer buf = {BUFSIZE};
    uint pos;

    oper init(Reader src) : __src = src {
        buf.size = 0;
    }
    
    void underflow() {
        throw Exception('Ran out of data.');
    }

    ## Returns the next integer, if we run out of data returns END or raises an 
    ## exception if errorOnUnderflow is true.  
    @final uint readUInt(bool errorOnUnderflow) {
        byte b = 0x80;
        uint val;
        uint offset;
        while (b & 0x80) {
            # make sure we've got data
            if (pos == buf.size) {
                buf.size = BUFSIZE;
                if (!__src.read(buf)) {
                    
                    # If we're erroring on underflow or we've already started 
                    # reading a value, raise an exception.
                    if (errorOnUnderflow || val)
                        underflow();
                    else
                        return END;
                }
                pos = 0;
            }

            # see if we've got the last byte
            b = buf[pos++];
            val = val | ((b & 0x7f) << offset);
            offset += 7;
        }

        return val;
    }
    
    ## Reads a uint, raises an exception if we run out of data.
    @final uint readUInt() { return readUInt(true); }

    ## Reads a string of size 'size' from the buffer.
    @final CString readFixedString(uint size) {
        # see if we've got enough space in the buffer, if so just copy the
        # string.
        if (buf.size - pos >= size) {
            result := CString(buf.buffer + pos, size, false);
            pos += size;
            return result;
        }
        
        # create a new managed buffer, copy the rest of the existing buffer 
        # into it.
        ManagedBuffer mbuf = {size + 1};
        mpos := buf.size - pos;
        mbuf.move(0, buf.buffer + pos, mpos);
        
        # read the rest of the string
        while (mpos < size) {
            amtRead := __src.read(WriteBuffer(mbuf.buffer + mpos,
                                              size - mpos
                                              )
                                  );
            if (!amtRead)
                underflow();
            mpos += amtRead;
        }
        
        # add null terminator
        mbuf.buffer[mbuf.cap - 1] = 0;

        # indicate that we've depleted the buffer
        pos = buf.size;

        size = mbuf.cap - 1;
        return CString(mbuf.orphan(), size, true);
    }

    ## If errorOnUnderflow is false, returns null if we run out of data 
    ## during read.
    @final CString readString(bool errorOnUnderflow) {
        size := readUInt();
        if (size == END) {
            if (errorOnUnderflow)
                underflow();
            else
                return null;
        }
        
        return readFixedString(size);
    }

    ## Reads a string, throws an exception if there is not enough data.    
    @final CString readString() { return readString(true); }
    
    
    # Ensure that the buffer contains at least 'size' bytes of data.    
    @final void ensureBufferSize(uint size) {
        if (buf.size - pos < size) {
            buf.compact(pos);
            pos = 0;
            buf.size += __src.read(WriteBuffer(buf.buffer + buf.size, 
                                               buf.cap - buf.size
                                               )
                                   );
            if (buf.size < size)
                underflow();
        }
    }

    # the floating point serialization routines rely on the in-memory 
    # representation of a float being IEEE.  I'm not sure if this is true on 
    # all systems.
    
    float32 readFloat32() {
        # make sure we have 4 bytes
        ensureBufferSize(4);
        
        result := array[float32](buf.buffer + pos)[0];
        pos += 4;
        return result;
    }

    float64 readFloat64() {
        # make sure we have 8 bytes
        ensureBufferSize(8);
        
        result := array[float64](buf.buffer + pos)[0];
        pos += 8;
        return result
    }

    void formatTo(Formatter o) {
        o `$(String(buf, 0, pos).getRepr())\n`;
        o `$(String(buf, pos, buf.size - pos).getRepr())\n`;
    }

    void writeTo(Writer out) {
        StandardFormatter o = {out};
        formatTo(o);
    }
}

class SerialWriter {
    
    Writer __dst;
    AppendBuffer buf = {1024};
    
    oper init(Writer dst) : __dst = dst {}
    
    void write(uint val) {
        
        # special case 0
        if (!val) {
            __dst.write('\0');
            return;
        }

        while (val) {
            b := byte(val & 0x7f);
            val >>= 7;
            if (val)
                b |= 0x80;
            buf.append(b);
        }

        # write the temp buffer and reset it.
        __dst.write(Buffer(buf.buffer, buf.size));
        buf.size = 0;
    }
    
    void write(String val) {
        write(uint32(val.size));
        __dst.write(val);
    }
    
    void write(float32 val) {
        array[float32](buf.buffer)[0] = val;
        __dst.write(Buffer(buf.buffer, 4));
    }
    
    void write(float64 val) {
        array[float64](buf.buffer)[0] = val;
        __dst.write(Buffer(buf.buffer, 8));
    }
    
    void flush() {
        __dst.flush();
    }
}
