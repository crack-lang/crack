
#!/usr/bin/crack
# Copyright 2010 Google Inc.

import crack.runtime abort, free, strcpy, strlen, malloc, memcpy, memcmp, 
    memmove;
@import crack._poormac define;

bool true = (1 == 1);
bool false = (1 == 0);

void _die(byteptr message) {
    puts(message);
    abort();
}

class Writer;

void _writeObject(Writer out);

## Base class for things that you don't want derived from object or VTableBase.
class FreeBase {};

## The Object base class.  Object provides the basic reference counting 
## mechanism, and most user classes should be derived from it.
class Object : VTableBase {
    uint refCount;

    # have to declare these before "oper init" otherwise it won't generate a 
    # bind in "oper new"
    oper bind();
    oper release();

    oper init() : refCount = 0 {
    }

    # delete virtual function
    oper del() { 
        if (refCount) {
            _die("Object with non-zero ref count deleted!");
        }
    }

    oper bind() {
        if (!(this is null))
            refCount = refCount + 1;
    }
    
    oper release() {
        if (this is null)
            return;

        refCount = refCount - 1;
        if (refCount == 0) {
            this.oper del();
            free(this);
        }
    }
    
    bool isTrue() {
        return true;
    }
    
    ## Comparison function - returns a value < 0 if this < other, 0 if this is 
    ## equal to other, > 0 if this > other.
    int cmp(Object other) {
        if (this is other) return 0; else return 1;
    }
    
    @final bool oper <(Object other) {
        return this is null ? !(other is null) : cmp(other) < 0;
    }
    
    @final bool oper <=(Object other) {
        return this is null ? true : cmp(other) <= 0;
    }
    
    @final bool oper ==(Object other) {
        return this is null ? other is null : cmp(other) == 0;
    }
    
    @final bool oper !=(Object other) {
        return this is null ? !(other is null) : cmp(other) != 0;
    }

    @final bool oper >=(Object other) {
        return this is null ? other is null : cmp(other) >= 0;
    }

    @final bool oper >(Object other) {
        return this is null ? false : cmp(other) > 0;
    }

    @final bool toBool() {
        if (this is null)
            return false;
        else
            return isTrue();
    }
    
    void writeTo(Writer writer) {
        _writeObject(writer);
    }
};

## Base class for interfaces - these are classes that are not derived from 
## Object but must be mixed in with classes derived from Object.  You can use 
## them to define a interfaces and functionality that a derived class must 
## conform to without limiting the inheritence of the derived class.
##
## Unfortunately, this pattern only allows a single MixIn since you cannot 
## inherit from the mixin class more than once.
##
## Derived classes must implement the getObject() method.
class MixIn : VTableBase {
    
    ## Returns the underlying Object of the concrete class derived from the
    ## mix-in.  This is used by our bind and release operators to allow 
    ## mix-ins to work with Object's reference counting.
    Object getObject() {
        _die('MixIn.getObject() not implemented.');
        return null;
    }

    # defining bind and release here takes advantage of the fact that the 
    # same final functions can be inherited from multiple ancestors.  This is 
    # arguably a bug, but we're going to exploit it for now.

    oper bind() { if (!(this is null)) getObject().oper bind(); }
    oper release() { if (!(this is null)) getObject().oper release(); }
}

class Buffer;

class Writer : VTableBase {
    void write(Buffer data) {
        puts(this.class.name);
        _die("Writer.write() not implemented.");
    }
    
    ## Flush the contents of the buffer.
    void flush() {}

    # MixIn stuff
    Object getWriterObject() {
        _die('Writer.getWriterObject() not implemented.');
        return null;
    }
    oper bind() { if (!(this is null)) getWriterObject().oper bind(); }
    oper release() { if (!(this is null)) getWriterObject().oper release(); }
}

## The buffer base class containing a bytebuf and size.
class Buffer : Object {

    // buffer and size.
    uint size;    
    byteptr buffer;

    oper init(byteptr buffer0, uint size0) : buffer = buffer0, size = size0 {}
    
    bool isTrue() {
        return size;
    }
    
    bool isEmpty() {
        return (size == 0);
    }
    
    void writeTo(Writer writer) {
        writer.write(this);
    }

    byte oper [](uint index) {
        if (index >= size)
            _die('string index out of bounds');
        return buffer[index];
    }

    byte oper [](int index) {
        if (index < 0 || index >= size)
            _die('string index out of bounds');
        return buffer[uint(index)];
    }

    ## Override Object.cmp() to do buffer comparison.
    int cmp(Object other) {
        
        # deal with the simple case
        if (this is other)
            return 0;

        # if the other object is a string, do string comparison.
        if (other.class.isSubclass(Buffer)) {
            os := Buffer.unsafeCast(other);
            
            # if both strings are the same size, this is just a straight 
            # memcmp().
            int rc;
            if (size == os.size) {
                return memcmp(buffer, os.buffer, size);
            
            # if one string is longer than the other, only compare the
            # common-sized substring and if those are equal, the longer one is
            # greater
            } else if (size > os.size) {
                rc = memcmp(buffer, os.buffer, os.size);
                if (!rc) rc = 1;
            } else {
                rc = memcmp(buffer, os.buffer, size);
                if (!rc) rc = -1;
            }
            return rc;
        } else {
            # if other is not a string, it is not equal.
            return 1;
        }
    }
}

void _writeObject(Writer out) {
    out.write(Buffer('<Object>', 8));
}

## A writable buffer.  You can assume that it is safe to write to one of these.
class WriteBuffer : Buffer {

    ## constructor inheritence would be nice
    oper init(byteptr buffer0, uint size0) : Buffer(buffer0, size0) {}

    ## Move data from an arbitrary byteptr into the buffer.
    void move(uint start, byteptr ptr, uint count) {
        if (start + count > size)
            _die('Move target out of bounds');
        memmove(buffer + start, ptr, count);
    }

    ## move data from one place in the buffer to another place in the buffer.
    void move(uint newStart, uint oldStart, uint count) {
        if (oldStart + count > size)
            _die('Move source out of bounds');
        move(newStart, buffer + oldStart, count);
    }
    
    ## move a buffer to a place in this buffer.
    void move(uint newStart, Buffer buf) {
        if (newStart + buf.size > size)
            _die('Move target out of bounds');
        move(newStart, buf.buffer, buf.size);
    }
};

## A managed buffer.  Deletes the bytebuf when it goes out of scope.
class ManagedBuffer : WriteBuffer {

    oper init(uint size0) : WriteBuffer(malloc(size0), size0) {}

    ## Orphan's the byte buffer, returning it for use by the caller.  The 
    ## caller is responsible for freeing it.
    byteptr orphan() {
        temp := buffer;
        buffer = null;
        size = 0;
        return temp;
    }
    
    ## Grow the buffer to the new size.
    void grow(uint newSize) {
        if (newSize <= size) {
            puts('attempt to grow to a smaller or same size.');
            abort();
        }
        
        newBuffer := malloc(newSize);
        if (!(buffer is null)) {
            memcpy(newBuffer, buffer, size);
            free(buffer);
        }
        buffer = newBuffer;
        size = newSize;
    }
    
    oper del() {
        if (!(buffer is null))
            free(buffer);
    }
};

## AppendBuffer lets you add stuff onto the end of it.
class AppendBuffer : ManagedBuffer {
    uint pos;

    oper init(uint size0) : ManagedBuffer(size0) {}

    ## Append a single byte to the buffer, growing if necessary.
    void append(byte c) {
        if (pos >= size)
            grow(size * 2);
        buffer[pos++] = c;
    }
    
    ## Extend the buffer with the other buffer.
    void extend(Buffer other) {
        uint newPos = pos + other.size;
        if (newPos > size)
            # grow to the larger of newPos and size * 2
            if (newPos > size * 2)
                grow(newPos);
            else
                grow(size * 2);
        move(pos, other);
        pos = newPos;
    }
}

# substring forward declarations - we need the full array to support doing 
# these efficiently

class SubString;
class String;
SubString _substr(SubString target, uint pos, uint len);
SubString substr(SubString target, int pos, uint len);
SubString substr(SubString target, int pos);
SubString slice(SubString target, int start, int end);
SubString slice(SubString target, int start);
SubString _substr(String target, uint pos, uint len);
SubString substr(String target, int pos, uint len);
SubString substr(String target, int pos);
SubString slice(String target, int start, int end);
SubString slice(String target, int start);

@define substr2 1 {

        # adjust a negative position
        if (pos < 0)
            pos = int($1.size) + pos;

        return _substr($1, uint(pos), len);
    }
$$

@define substr1 1 {

        # adjust a negative position
        if (pos < 0)
            pos = int($1.size) + pos;

        return _substr($1, uint(pos), $1.size - uint(pos));
    }
$$

@define slice2 1 {

        # adjust negative offsets    
        if (start < 0)
            start = int($1.size) + start;
        if (end < 0)
            end = int($1.size) + end;
    
        # bounds checking
        if (end < start)
            _die('Start of slice is after end.');
    
        return _substr($1, uint(start), uint(end - start));
    }
$$

@define slice1 1 {

        # adjust negative offsets
        if (start < 0)
            start = int($1.size) + start;
    
        # bounds checking
        if (uint(start) > $1.size)
            _die('Start of slice is after end.');
    
        return _substr($1, uint(start), $1.size - uint(start));
    }
$$

## The string class.  Strings are immutable managed Buffer's - when they are 
## deleted, their buffer goes away. 
## The buffer is not guaranteed to be null-terminated, use CString if
## that's a requirement
class String : Buffer {

    ## Initialize from a buffer.  This copies the buffer, it does not assume 
    ## ownership.
    oper init(Buffer buf) : Buffer(malloc(buf.size), buf.size) {
        memcpy(buffer, buf.buffer, buf.size);
    }

    ## Initialize from a WriteBuffer and optionally take ownership of the 
    ## buffer.
    oper init(ManagedBuffer buf, bool takeOwnership) : 
        Buffer(null, 0) {
        
        if (takeOwnership) {
            size = buf.size;
            buffer = buf.orphan();
        } else {
            size = buf.size;
            buffer = memcpy(malloc(buf.size), buf.buffer, buf.size);
        }
    }
    
    ## Initialize from a substring of buffer.  This copies the buffer from 
    ## index pos to pos + len.  It does not assume ownership.
    oper init(Buffer buf, uint pos, uint len) : Buffer(malloc(len), len) {
        if (pos + len > buf.size)
            _die('out of bounds copy');
        memcpy(buffer, buf.buffer + pos, len);
    }

    ## Initialize from byte pointer and size and optionally take ownership.
    oper init(byteptr buf, uint size0, bool takeOwnership) :
        Buffer(takeOwnership ? buf : memcpy(malloc(size0), buf, size0), 
               size0
               ) {
    }
    
    ## Initialize from a null-terminated c-string
    oper init(byteptr cString) : Buffer(null, strlen(cString)) {
        buffer = malloc(size + 1);
        strcpy(buffer, cString);
    }

    ## Create an empty string.
    oper init() : Buffer(malloc(0), 0) {}
    
    void _freeBuffer() {
        free(buffer);
    }
    
    oper del() {
        _freeBuffer();
    }

    ## Find the rightmost index of a character in a string
    ## returns -1 if not found
    ## note this function is not safe for strings larger than INT_MAX
    int rfind(byte c) {
        uint i = size; // loop start with decrement so we start one high
        bool brk = false;
        while (!brk) {
            i--;
            if (buffer[i] == c)
                return int(i); // warning, possible truncate
            brk = (i == 0);
        }
        return -1;
    }

    ## Find the leftmost index of a character in a string
    ## returns -1 if not found
    ## note this function is not safe for strings larger than INT_MAX
    int lfind(byte c) {
        uint i = 0;
        while (i++ < size) {
            if (buffer[i] == c)
                return int(i); // warning, possible truncate
        }
        return -1;
    }

    ## Concatenation
    String oper +(String rhs) {
        uint newBufferSize = this.size + rhs.size;
        byteptr newRawBuffer = malloc(newBufferSize);
        memcpy(newRawBuffer, this.buffer, this.size);
        memcpy(newRawBuffer+this.size, rhs.buffer, rhs.size);
        return String(newRawBuffer, newBufferSize, true);
    }

    # note, not binary safe
    String oper +(byteptr rhs) {
        uint rhs_size = strlen(rhs);
        uint newBufferSize = size + rhs_size;
        byteptr newRawBuffer = malloc(newBufferSize);
        memcpy(newRawBuffer, buffer, size);
        memcpy(newRawBuffer + size, rhs, rhs_size);
        return String(newRawBuffer, newBufferSize, true);
    }
    
    ## Create a substring.  This function is smart enough to know if the 
    ## receiver is already a SubString, in which case it will translate to 
    ## the underlying String to avoid creating a stack of SubStrings.
    ## If 'pos' is negative, it is an offset from the end of the string.
    SubString substr(int pos, uint len) @substr2 this
    
    ## Create a substring from 'pos' to the end of the string.
    SubString substr(int pos) @substr1 this

    ## Slice is similar to substr, except that it accepts a start and end 
    ## position (instead of a start position and length).  Both the start 
    ## and end positions can be negative, indicating that they are relative 
    ## to the end of the string.
    SubString slice(int start, int end) @slice2 this

    # Another variation on slice(), this gives a slice from 'start' to the 
    # end of the string.
    SubString slice(int start) @slice1 this

    ## Returns a legal source representation of the string.
    String getRepr() {
        AppendBuffer buf = {size + 2};
        
        buf.append(39); # "'"
        for (uint i = 0; i < size; ++i) {
            ch := buffer[i];
            if (ch < 32 || ch > 127 || ch == 39 || ch == 92) {
                buf.append(92); # '\'
                buf.append(48 + (ch >> 6));
                buf.append(48 + ((ch & 56) >> 3));
                buf.append(48 + (ch & 7));
            } else {
                buf.append(ch)
            }
        }
        buf.append(39);
        
        buf.size = buf.pos;
        return String(buf, true);
    }
};

## A substring of an existing string object.  Substrings are much
## lighter weight than full String objects because SubString doesn't manage 
## its own buffer.  It references the buffer of its underlying String.
class SubString : String {
    String _rep = null;

    ## Create a stubstring 'target' starting from 'pos' and of length 'len'.
    oper init(String target, uint pos, uint len) : 
        String(target.buffer + pos, len, true),
        _rep = target {
    }

    ## Create a substring from 'pos' to the end of the string.
    oper init(String target, uint pos) : 
        String(target.buffer + pos, target.size - pos, true),
        _rep = target {
    }
    
    oper init(String target, byteptr buf, uint len) :
        String(buf, len, true),
        _rep = target {
    }

    # duplicate the substring/slice interface since we can do them more 
    # efficiently here

    SubString substr(int pos, uint len) @substr2 this
    SubString substr(int pos) @substr1 this
    SubString slice(int start, int end) @slice2 this
    SubString slice(int start) @slice1 this

    void _freeBuffer() {}
}

SubString _substr(SubString target, uint pos, uint len) {
    # do bounds checking
    if (pos > target.size || pos + len > target.size)
        _die('Substring out of bounds');

    byteptr buf = target.buffer + uint(pos);
    return SubString(target._rep, buf, len);
}

SubString substr(SubString target, int pos, uint len) @substr2 target
SubString substr(SubString target, int pos) @substr1 target
SubString slice(SubString target, int start, int end) @slice2 target
SubString slice(SubString target, int start) @slice1 target

SubString _substr(String target, uint pos, uint len) {
    # do bounds checking
    if (pos > target.size || pos + len > target.size)
        _die('Substring out of bounds');

    byteptr buf = target.buffer + pos;
    if (target.class.isSubclass(SubString))
        target = SubString.cast(target)._rep;

    return SubString(target, buf, len);
}

SubString substr(String target, int pos, uint len) {
    # adjust a negative position
    if (pos < 0)
        pos = int(target.size) - pos;

    return _substr(target, uint(pos), len);    
}

SubString substr(String target, int pos) {
    # adjust a negative position
    if (pos < 0)
        pos = int(target.size) - pos;

    return _substr(target, uint(pos), target.size - uint(pos));
}

SubString slice(String target, int start, int end) {

    # adjust negative offsets    
    if (start < 0)
        start = int(target.size) + start;
    if (end < 0)
        end = int(target.size) + end;

    # bounds checking
    if (end < start)
        _die('Start of slice is after end.');

    return _substr(target, uint(start), uint(end - start));
}

SubString slice(String target, int start) {

    # adjust negative offsets    
    if (start < 0)
        start = int(target.size) + start;

    # bounds checking
    if (uint(start) > target.size)
        _die('Start of slice is after end.');

    return _substr(target, uint(start), target.size - uint(start));
}

## A string that is guaranteed to be null terminated. The trailing null is
## not included in the size of the string.
class CString : String {

    @final void __copy(byteptr buf, uint size0) {
        size = size0;
        buffer = malloc(size0 + 1);
        memcpy(buffer, buf, size0);
        buffer[size] = 0;
    }

    oper init(String s0) {
        __copy(s0.buffer, s0.size);
    }
    
    ## Initialize a the string from byteptr and size, take ownership of the 
    ## memory if requested.
    ## If takeOwnership is true, buf[size0] must be null.  This constructor 
    ## will not verify that this is the case.
    oper init(byteptr buf, uint size0, bool takeOwnership) :
        String(buf, size0, true) {
        if (!takeOwnership)
            __copy(buf, size0);
    }
    
    ## Initialize from a null-terminated byteptr, take ownership of the 
    ## memory if requested.
    oper init(byteptr buf, bool takeOwnership) :
        String(buf, strlen(buf) + 1, takeOwnership) {
        --size;
    }

}

class StaticString : String {

    oper init(byteptr data, uint size0) : String(data, size0, true) {}
    
    ## Initialize from a null terminated string.
    oper init(byteptr data) : String(data, strlen(data), true) {}
    
    # override _freeBuffer so we don't...
    void _freeBuffer() {}
};

void print(String val) {
    puts(val.buffer);
}

void print(StaticString val) {
    puts(val.buffer);
}

void puts(StaticString val) {
    puts(val.buffer);
}

void print(CString val) {
    puts(val.buffer);
}

void die(String message) {
    print(message);
    abort();
}

void die() {
    abort();
}
