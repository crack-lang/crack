# Copyright 2010 Google Inc.
# The Crack Container library.

import crack.io cout, cerr, Formatter, Writer;
import crack.lang die, free;

## Abstract base class of all iterators.
class Iterator {
    
    ## Return the element at the position.
    Object elem() { die('Iterator.elem() not implemented'); return null; }
    
    ## Forward to the next node, return true if there is one, false if we've 
    ## run out of elements.
    bool next() { die('Iterator.next() not implemented'); return false; }
    
    ## Forward to the next node unless this is the first time it is called, 
    ## allowing the pattern "while (iter.nx()) ..." to iterate over an entire 
    ## collection.
    ## Returns true if the iterator is valid.
    bool nx() { die('Iterator.nx() not implemented'); return false; }
    
    ## Returns true if the container is valid, allowing us to do "if (iter)"
    bool isTrue() { die('Iterator.isTrue() not implemented'); return false; }
}

class MapElem {
    Object key, val;
    oper init(Object key0, Object val0) : key = key0, val = val0 {}
}

## Base class for map iterators - maps are collections stored by key and value.
class MapIterator : Iterator {
    Object key() { die('MapIterator.key() not implemented'); return null; }
    Object val() { die('MapIterator.val() not implemented'); return null; }
    
    ## A sub-optimal implementation of elem() for maps - derived classes are 
    ## encouraged to override.
    Object elem() { return MapElem(key(), val()); }
}

## base class of all containers.
class Container {
    Iterator iter() {
        return null;
    }

    uint count() { die('Container.count() not implemented.'); return 0; }

    void writeTo(Writer writer) {
        out := Formatter(writer);
        i := iter();
        out `[`;
        if (i) out `$(i.elem())`;
        while (i.next())
            out `, $(i.elem())`;
        out `]`;
    }
}

# classes to support linked lists.

class ListNode {
    Object elem = null;
    ListNode next = null;
    
    oper init(Object elem0) : elem = elem0 {}
}

## A linked list iterator.
class ListIter : Iterator {
    ListNode _node = null;
    bool __first;
    oper init(ListNode node) : _node = node, __first = true {}
    
    Object elem() {
        if (_node)
            return _node.elem;
        else
            return null;
    }
    
    bool next() {
        if (!_node)
            return false;
        
        _node = _node.next;
        return _node;
    }

    bool nx() {
        if (!_node)
            return false;
        
        if (__first)
            __first = false;
        else
            _node = _node.next;
        return _node;
    }
    
    bool isTrue() { return _node; }
}

## A singly-linked list.
class List : Container {
    ListNode head = null;
    ListNode tail = null;
    uint _count;
    
    Iterator iter() {
        return ListIter(head);
    }

    ListNode _createNode(Object elem, ListNode prev) {
        return ListNode(elem);
    }
    
    void append(Object elem) {
        if (tail) {
            temp := _createNode(elem, tail);
            tail.next = temp;
            tail = temp;
        } else {
            head = tail = _createNode(elem, null);
        }
        _count = _count + 1;
    }
    
    void pushHead(Object elem) {
        newNode := _createNode(elem, null);
        if (head) {
            newNode.next = head;
            head = newNode;
        } else {
            head = tail = newNode;
        }
        _count = _count + 1;
    }
    
    void pushTail(Object elem) {
        append(elem);
    }
    
    ## Remove the element from the front of the list and return it.
    Object popHead() {
        if (!head) die('popHead(): empty list');
        elem := head.elem;
        head = head.next;
        --_count;
        return elem;
    }

    void insert(uint index, Object elem) {
        # special-case inserting at the beginning
        if (!index) {
            pushHead(elem);
            return;
        }

        # find the node that's going to be before the new node
        i := index - 1;
        ListNode node = head, lastNode = null;
        while (i && node) {
            i = i - 1;
            node = node.next;
        }
        if (!node) die('List index out of bounds.');

        # create a new node and append it to the node we found
        newNode := _createNode(elem, node);
        newNode.next = node.next;
        node.next = newNode;
        
        # see if we need to fix the tail
        if (node is tail)
            tail = newNode;
        _count = _count + 1;
    }

    ListNode __findNode(uint index) {
        i := index;
        node := head;
        while (i && node) {
            node = node.next;
            i = i - 1;
        }
        if (!node) die('Assertion failed in oper []');
        return node;
    }
    
    void delete(uint index) {
        if (index > _count)
            die('List index out of range in delete()');
        if (index > 0) {
            # find the node before it.
            node := __findNode(index - 1);
            
            # if the next node is the tail, reset the tail.
            if (node.next is tail)
                tail = node;
            
            # drop the current next node.
            tmp := node.next.next;
            node.next = tmp;
        } else {
            # first node is special and easy
            tmp := head.next;
            head = tmp;
        }
        
        _count = _count - 1;
    }

    Object oper [](uint index) {
        if (index > _count)
            die('List index out of range in []');
        node := __findNode(index);
        return node.elem;
    }
    
    uint count() { return _count; }
}

class DListNode : ListNode {
    DListNode _prev = null;

    oper init(Object elem0, ListNode prev) :
        ListNode(elem0), 
        _prev = DListNode.unsafeCast(prev) {
    }
}

class DListIter : ListIter {
    oper init(DListNode node) : ListIter(node) {}
    
    bool last() { _node = DListNode.unsafeCast(_node)._prev; return _node; }
}

## Doubly-linked list
class DList : List {
    
    oper del() {
        # have to break the reference cycles
        node := DListNode.unsafeCast(head);
        while (node) {
            node._prev = null;
            node = DListNode.unsafeCast(node.next);
        }
    }

    ListNode _createNode(Object elem, ListNode prev) {
        return DListNode(elem, prev);
    }

    void insert(Iterator ix, Object elem) {
        i := DListIter.cast(ix);
        
        # get what will be the next and previous node of the new node.
        next := DListNode.unsafeCast(i._node);
        prev := next._prev;
        new := DListNode.unsafeCast(_createNode(elem, prev));
        new.next = next;

        if (prev)
            prev.next = new;
        else
            head = new;

        if (next)
            next._prev = new;
        else
            tail = new;
        
        i._node = new;
        ++_count;
    }

    ## Insert the object at the iterator (after insertion, the iterator will 
    ## reference a new node with the element, the old node that
    ## iterator referenced will be the next node)
    void delete(Iterator ix) {
        i := DListIter.cast(ix);
        node := DListNode.unsafeCast(i._node);
        if (node.next)
            DListNode.unsafeCast(node.next)._prev = node._prev;
        else
            tail = node._prev;
        
        if (node._prev)
            node._prev.next = node.next;
        else
            head = node.next;
        
        --_count;
        i._node = node.next;
    }

    Object popHead() {
        if (!head) die('popHead(): empty list');
        elem := head.elem;
        head = head.next;
        DListNode.unsafeCast(head)._prev = null;
        --_count;
        return elem;
    }
    
    ## Remove the element from the back of the list and return it.
    Object popTail() {
        if (!tail) die('popTail(): empty list');
        elem := tail.elem;
        node := DListNode.unsafeCast(tail);
        tail = node._prev;
        node._prev.next = null;
        --_count;
        return elem;
    }

    Iterator iter() {
        return DListIter(DListNode.unsafeCast(head));
    }
    
    ## Returns a bidirectional iterator.
    ## if 'back' is true, initialize it to point to the last node on the list. 
    ## Otherwise point it to the first node.
    DListIter bidiIter(bool back) {
        if (back)
            return DListIter(DListNode.unsafeCast(tail));
        else
            return DListIter(DListNode.unsafeCast(head));
    }    
}

class _ArrayIface : Container {
    
    Object oper [](uint index) {
        die('_ArrayIface.oper []() not implemented');
        return null;
    }
    
    uint count() {
        die('_ArrayIface.count() not implemented');
        return 0;
    }
}

class ArrayIter : Iterator {
    _ArrayIface __arr;
    uint __index;
    bool __first = true;

    oper init(_ArrayIface arr) : __arr = arr {}
    
    Object elem() {
        return __arr[__index];
    }
    
    bool next() {
        count := __arr.count();
        if (__index < count) {
            __index = __index + 1;
            return __index < count;
        } else {
            return false;
        }
    }

    bool nx() {
        if (__first) {
            __first = false;
            return __index < __arr.count();
        } else {
            return next();
        }
    }
    
    bool isTrue() {
        return __index < __arr.count();
    }
}

## An Array is a sequence backed by a low-level array.  It supports the 
## bracket operators and adding items at the end.
class Array : _ArrayIface {
    
    array[Object] __rep = null;
    uint __cap, __size;
    
    oper init(uint initCapacity) :
        __rep = array[Object](initCapacity), 
        __cap = initCapacity,
        __size = 0 {
    }
    
    oper init() : 
        __rep = array[Object](16), 
        __cap = 16,
        __size = 0 {
    }
    
    oper del() {
        uint i;
        while (i < __size) {
            __rep[i].oper release();
            i = i + 1;
        }
        free(__rep);
    }
    
    void realloc(uint newCapacity) {
        if (newCapacity < __cap)
            die('Array.realloc() - decreasing capacity');
            
        newRep := array[Object](newCapacity);
        
        # move all of the entries to the new array.
        uint i;
        while (i < __size) {
            newRep[i] = __rep[i];
            i = i + 1;
        }

        free(__rep);
        __rep = newRep;
        __cap = newCapacity;
    }
    
    void append(Object elem) {
        if (__size == __cap)
            realloc(__cap * 2);
        
        __rep[__size] = elem;
        elem.oper bind();
        __size = __size + 1;
    }

    void swap(uint index1, uint index2) {
        if (index1 > __size || index2 > __size)
            die('Index out of range in Array.swap');
        if (index1 == index2)
            return;
        tmp := __rep[index2];
        __rep[index2] = __rep[index1];
        __rep[index1] = tmp;
    }

    Object oper [](uint index) {
        if (index > __size)
            die('Index out of range in Array.oper []');
        
        return __rep[index];
    }

    void oper []=(uint index, Object elem) {
        if (index > __size)
            die('Index out of range in Array.oper []=');
        
        __rep[index].oper release();
        __rep[index] = elem;
        elem.oper bind();
    }
    
    Iterator iter() {
        return ArrayIter(this);
    }
    
    uint count() {
        return __size;
    }
    
    uint capacity() {
        return __cap;
    }
    
    ## delete the element at 'index'.
    void delete(uint index) {
        if (index > __size)
            die('Index out of range in Array.delete()');
        
        # release the object at the index
        __rep[index].oper release();
        
        # move everything else down one
        uint i = index;
        while (i < __size - 1) {
            __rep[i] = __rep[i + 1];
            ++i;
        }
        --__size;
    }   
}

## Holds a key/value pair.
class KeyVal {
    Object key, val;

    oper init(Object key0, Object val0) : key = key0, val = val0 {}

    int cmp(Object other) {
        if (other.class.isSubclass(KeyVal))
            return key.cmp(KeyVal.unsafeCast(other).key);
        else
            return key.cmp(other);
    }
    
    void writeTo(Writer out) {
        Formatter(out) `$key: $val`;
    }
}

## Red-black tree node.
class RBTreeNode {
    
    # if true, this is a red node
    bool red;
    RBTreeNode left = null, right = null, parent = null;
    Object val = null;
    
    oper init(Object val0, bool red0) : red = red0, val = val0 {}
    
    void doIndent(uint indent) {
        i := indent;
        while (i) { i = i - 1; cout `  `; }
    }
    
    void dump(uint indent) {
        doIndent(indent);
        String color;
        if (red)
            color = 'red';
        else
            color = 'black';
        cout `$color, val = $val\n`;
        doIndent(indent);
        cout `left:\n`;
        if (left) {
            left.dump(indent + 1);
        } else {
            doIndent(indent);
            cout `  null\n`;
        }
        doIndent(indent);
        cout `right:\n`;
        if (right) {
            right.dump(indent + 1);
        } else {
            doIndent(indent);
            cout `  null\n`;
        }
    }

    ## Find and return the node matching the target, returns null if the value
    ## is not found.
    RBTreeNode find(Object target) {
        diff := -val.cmp(target);
        if (!diff)
            return this;
        else if (diff > 0 && right)
            return right.find(target);
        else if (diff < 0 && left)
            return left.find(target);
        else
            return null;
    }
    
    RBTreeNode __grandparent() {
        if (parent)
	   return parent.parent;
	else
            return null;
    }

    RBTreeNode __uncle() {
        g := __grandparent();
        if (!g)
            return null;
        if (parent == g.left)
            return g.right;
        else
            return g.left;
    }

    void __setLeft(RBTreeNode node) {
        left = node;
        if (node)
            node.parent = this;
    }
    
    void __setRight(RBTreeNode node) {
        right = node;
        if (node)
            node.parent = this;
    }

    void __setParent(RBTreeNode newParent, bool isRightChild) {
        if (newParent)
            if (isRightChild)
                newParent.__setRight(this);
            else
                newParent.__setLeft(this);
        else
            parent = null;
    }

    ## Returns the root of the nodes tree.
    RBTreeNode getRoot() {
        p := this;
        while (p.parent)
            p = p.parent;
        return p;
    }
        
    ## Rotate the node to the left so its new parent is its old right child.
    void rotateLeft() {
        newParent := right;
        orgParent := parent;
        isRight := parent && this is parent.right;
        newRight := newParent.left;
        newParent.__setLeft(this);
        __setRight(newRight);
        newParent.__setParent(orgParent, isRight);
    }
    
    ## rotate the node to the right so its new parent is its old left node.
    void rotateRight() {
        newParent := left;
        orgParent := parent;
        isRight := parent && this is parent.right;
        newLeft := newParent.right;
        newParent.__setRight(this);
        __setLeft(newLeft);
        newParent.__setParent(orgParent, isRight);
    }

    void __rebalance() {
        if (!parent) {
            # this is the root node.  Mark it as black, root node is always 
            # black. (we could actually omit this case, since we're dealing 
            # with it externally).
            red = false;
        } else if (!parent.red) {
            # parent is black, no rules are invalidated.
            return;
        } else {
            # parent is red.
            RBTreeNode uncle = __uncle(), gramps = null;
 
            if (uncle && uncle.red) {
                # both the parent and the uncle are red.  Paint them black, 
                # paint gramps red and rebalance him.
		parent.red = false;
		uncle.red = false;
		gramps = __grandparent();
		gramps.red = true;
                gramps.__rebalance();
        	   } else {
        	       # parent is red, uncle is black.
        	       RBTreeNode node = null;
        	       gramps = __grandparent();
        	       if (this is parent.right && parent is gramps.left) {
        	           # this is the right child of a left child.  Rotate left 
        	           # and perform subsequent operations on what was my parent 
        	           # (and is now my left child).
                    parent.rotateLeft();
                    root := parent;
                    node = left;
                    gramps = parent;
                } else if (this is parent.left && parent is gramps.right) {
                    # this is the left child of a right child.  Do the 
                    # opposite of the last case.
                    parent.rotateRight();
                    node = right;
                    gramps = parent;
                } else {
                    node = this;
                }
                
                # the parent is red, the uncle is black, the node is a left 
                # child of a left child or the right child of a right child.
                node.parent.red = false;
                gramps.red = true;
                if (node is node.parent.left && node.parent is gramps.left)
                    gramps.rotateRight();
                else /* (n == n->parent->right) and (n->parent == g->right) */
                    gramps.rotateLeft();
            }
        }
    }

    void insert(RBTreeNode newNode) {
        int diff = -val.cmp(newNode.val);
        if (diff == 0) {
            # we match - replace our value
            val = newNode.val;

        # normal b-tree insert.  If the new node is greater than the current 
        # node, look to the right.
        } else if (diff > 0) {
            if (!right) {
                right = newNode;
                newNode.parent = this;
                newNode.__rebalance();
            } else {
                right.insert(newNode);
            }
        } else {
            if (!left) {
                left = newNode;
                newNode.parent = this;
                newNode.__rebalance();
            } else {
                left.insert(newNode);
            }
        }
    }
    
    ## Find the maximum node in the subtree.
    RBTreeNode findMax() {
        if (right)
            return right.findMax();
        else
            return this;
    }
    
    ## Returns the minimum node in the subtree.
    RBTreeNode findMin() {
        if (left)
            return left.findMin();
        else
            return this;
    }

    ## Replace the node in its parent with the new child.
    void __replaceMe(RBTreeNode child) {
        if (this is parent.left)
            parent.__setLeft(child);
        else
            parent.__setRight(child);
    }

    RBTreeNode __sibling() {
        if (this is parent.left)
            return parent.right;
        else
            return parent.left;
    }

    void __rebalanceAfterDelete() {
        # case 1: if this is the root node, we're done.
        if (parent is null)
            return;
        
        sibling := __sibling();

        # case 2: sibling is red.        
        if (sibling.red) {
            # reverse the colors of the parent and sibling
            parent.red = true;
            sibling.red = false;
            
            # rotate so that the sibling is the new parent
            if (this is parent.left)
                parent.rotateLeft();
            else
                parent.rotateRight();
            
            # find the new sibling
            sibling = __sibling();
        }
        
        # we now know the sibling is black.
        # record whether the sibling and its children are black. (we already 
        # know that sibling is black)
        siblingAndChildrenBlack :=
            (!sibling.left || !sibling.left.red) &&
            (!sibling.right || !sibling.right.red)
            ;
        
        # case 3: parent, sibling and all of the sibling's children are 
        # black.
        if (!parent.red && siblingAndChildrenBlack) {
            sibling.red = true;
            parent.__rebalanceAfterDelete();
            return;
        }
        
        # case 4: parent is red, sibling and all of its children are black.  
        # We can just swap colors on parent and sibling.
        if (siblingAndChildrenBlack) {
            sibling.red = true;
            parent.red = false;
            return;
        }
        
        # case 5: sibling is black (asserted by failure of case 2), 
        # sibling's left child is red and this node is the left child of its 
        # parent.
        # We deal with case 5 by turning it into something that satisfies case
        # 6 and then falling through to case 6 processing.
        if ((sibling.left && sibling.left.red) &&
            (!sibling.right || !sibling.right.red) &&
            this is parent.left
            ) {
            # change the colors of the sibling and its child and fall through 
            # to case 6.
            sibling.red = true;
            sibling.left.red = false;
            sibling.rotateRight();
            sibling = sibling.parent;
        
        # case 5, on the right side
        } else if ((sibling.right && sibling.right.red) &&
                   (!sibling.left || !sibling.left.red) &&
                   this is parent.right
                   ) {
            sibling.red = true;
            sibling.right.red = false;
            sibling.rotateLeft();
            sibling = sibling.parent;
        }
        
        # case 6: sibling is black, sibling's right child is red and this node 
        # is the left child node of its parent.
        sibling.red = parent.red;
        parent.red = false;
        if (this is parent.left) {
            sibling.right.red = false;
            parent.rotateLeft();
        
        # case 6 on the right
        } else {
            sibling.left.red = false;
            parent.rotateRight();
        }
    }

    ## an "elbow node" is a node with at most one non-leaf child (keep in mind
    ## that leaves are nulls in an rbtree, so a node with at most one non-null
    ## child).
    void __deleteElbowNode() {
        child := left;
        if (!child)
            child = right;

        # if the node is red we can just replace it with the child
        if (red) {
            __replaceMe(child);

        # if the node is black but its child is red, we can replace it with 
        # the child and paint the child black.
        } else if (!red && child && child.red) {
            __replaceMe(child);
            child.red = false;

        # both the node and child are black.
        } else {
            if (child)
                die('child is supposed to be null!');
            # replace the node with its child, then rebalance the child
            
            # XXX what we would do if we were not using null to represent a 
            # leaf node.
            #__replaceMe(child);
            #child.__rebalanceAfterDelete();
            __rebalanceAfterDelete();
            __replaceMe(child);
        }
    }

    ## delete the node.  Returns true if the node is the root node.
    bool delete() {
        # find either the minimum in the left or the maximum in the right
        RBTreeNode node = null;
        if (left) {
            node = left.findMax();
        } else if (right) {
            node = right.findMin();
        } else {
            # we just have to delete this node.
            if (parent)
                node = this;
            else
                # no parent, this is the root node.
                return true;
        }
        
        # move the contents of the new node to this node
        if (!(node is this)) {
            val = node.val;
        }
        
        # really delete the new node
        node.__deleteElbowNode();
        return false;
    }

    ## Clear all parent pointers to remove cyclic references.
    void _unhookParents() {
        parent = null;
        if (left)
            left._unhookParents();
        if (right)
            right._unhookParents();
    }  
    
    # constraint validation
    
    ## check that both children of a red node are black
    bool checkRedChildrenBlack(Formatter report) {
        if (red && (left && left.red || right && right.red)) {
            report `RBTree.checkConstraints: red node $val has red child.\n`;
            return false;
        }
        bool result = true;
        if (left) {
            if (left.val >= val) {
                report `left value $(left.val) >= $val\n`;
                result = false;
            }
            left.checkRedChildrenBlack(report);
        }
        if (right) {
            if (right.val <= val) {
                report `right value $(right.val) <= $val\n`;
                result = false;
            }
            right.checkRedChildrenBlack(report);
        }
        return result;
    }
    
    int checkBlackCounts(Formatter report) {
        int leftCount, rightCount;
        if (left)
            leftCount = left.checkBlackCounts(report);
        if (right)
            rightCount = right.checkBlackCounts(report);
        
        # if we failed on either of the children, fail for the parent
        if (leftCount == -1 || rightCount == -1)
            return -1;
        
        if (leftCount != rightCount) {
            report `RBTree.checkConstraints: imbalanced black count at node \
$val\n`;
            return -1;
        }
        
        if (red)
            return leftCount;
        else
            return leftCount + 1;
    }
}

class RBTreeIter : Iterator {
    bool __first = true;
    RBTreeNode __node = null;
    
    void __findMin() {
        __node = __node.findMin();
    }
    
    void __next() {
        # if there's a right node, find its minimum.
        if (__node.right) {
            __node = __node.right.findMin();
        } else {
            # back up until we're either at the root or at the first parent 
            # that we are the left child of.
            while (__node.parent && __node is __node.parent.right)
                __node = __node.parent;
            
            # at this point, either the parent is null (in which case we're 
            # done) or we're at a left child.
            __node = __node.parent;
        }
    }
    
    oper init(RBTreeNode root) {
        if (root)
            __node = root.findMin();
    }
    
    bool next() {
        __next();
        return __node;
    }
    
    bool nx() {
        if (__first) {
            __first = false;
            return __node;
        } else {
            return next();
        }
    }
    
    Object elem() {
        if (__node)
            return __node.val;
        else
            return null;
    }
    
    bool isTrue() { return __node; }
}

class TreeMap : Container {
    
    RBTreeNode __root = null;
    uint __count;

    void oper []=(Object key, Object val) {
        if (__root) {
            __root.insert(RBTreeNode(KeyVal(key, val), true));

            # the root node may have changed due to rebalancing - find the new 
            # root.
            __root = __root.getRoot();
        } else {
            __root = RBTreeNode(KeyVal(key, val), false);
        }

        ++__count;
    }
    
    ## Returns the object with the specified key, returns null if the key
    ## is not in the tree.
    Object get(Object key) {
        if (__root) {
            node := __root.find(key);
            if (node) {
                v := KeyVal.cast(node.val);
                return v.val;
            }
        }
        
        return null;
    }
    
    Object oper [](Object key) {
        return get(key);
    }
    
    void dump() {
        if (__root)
            __root.dump(0);
        else
            cout `root is null\n`;
    }
    
    oper del() {
        if (__root) __root._unhookParents();
    }
    
    ## Delete the object with the specified key.
    void delete(Object key) {
        RBTreeNode node = null;
        if (__root)
            node = __root.find(key);
        if (!node)
            die('node not found in RBTree.delete()');

        # delete the node
        if (node.delete())
           # set the root to null if it was the root node with no children
            __root = null;
        else
            # find the new root node.
            __root = __root.getRoot();
        --__count;
    }
    
    bool checkConstraints(Formatter report) {
        # empty trees always pass.
        if (!__root)
            return true;
            
        result := true;

        # 1: a node is either red or black (duh)
        # 2: the root node is black
        if (__root.red) {
            report `RBTree.checkConstraints: The root is not black\n`;
            result = false;
        }
        
        # 3: all leaves are black is true because we define null as black
        # 4: both children of every red node are black.
        if (!__root.checkRedChildrenBlack(report))
            result = false;
        
        # 5: every simple path to a leaf traverses the same number of black 
        # nodes.
        if (__root.checkBlackCounts(report) == -1)
            result = false;
        
        return result;
    }
    
    uint count() {
        return __count;
    }
    
    Iterator iter() {
        return RBTreeIter(__root);
    }
}
