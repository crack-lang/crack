## Copyright 2010 Google Inc
## Module for manipulating ascii stirngs.

import crack.io cout;
import crack.lang ManagedBuffer, Buffer, AppendBuffer;
import crack.strutil StringArray, split;
 
## Returns the number converted to a string in the specified base - e.g. 
## radix(26, 16) -> '1a'
String radix(uintz val, uint base) {
    const SIZE := 20;
    ManagedBuffer tempBuf = {SIZE};
    byteptr cur = tempBuf.buffer + SIZE + -1;
    cur[0] = 0;
    cur = cur + -1;
    uint size;
    
    if (!val) {
        cur += -1;
        cur[0] = b'0';
        size = 1;
    } else {
        while (val) {
            cur += -1;
            b := byte(val % base);
            if (b < 10)
                b += b'0';
            else
                b += b'a' - byte(10);
            cur[0] = b;
            val = val / base;
            ++size;
        }
    }
    return String(cur, size, false);
}

## Parse a base 10 integer.
int parseInt(String rep) {
    int i, sign = 1, val;
    if (rep[0] == b'-') {
        ++i;
        sign = -1;
    }

    while (i < rep.size) {
        b := rep[i++];
        if (b >= b'0' && b <= b'9')
            val = val * 10 + b - b'0';
        else
            break;
    }

    return val * sign;
}

## Parse a boolean
bool parseBool(String rep) {
    if (rep.size == 1){
      if (rep[0] == b't' || rep[0] == b'T'|| rep[0] == b'1')
        return true;
      else return false
    }

    if (rep.size == 4){
      if ((rep[0] == b't' || rep[0] == b'T') &&
          (rep[1] == b'r' || rep[1] == b'R') &&
          (rep[2] == b'u' || rep[2] == b'U') &&
          (rep[3] == b'e' || rep[3] == b'E'))  
        return true;
    }
    return false;
}


String _changeCase(String text, byte lowerBound, byte upperBound, 
                   byte newOffset, 
                   uint num
                   )
{
    oldBuf := text.buffer;
    ManagedBuffer newVal = {text.size};
    newBuf := newVal.buffer;
    byte c;

    for (uint i = 0; i < num && i < text.size; i++){
        c = oldBuf[i];
        if (c >= lowerBound && c <= upperBound){
            byte offset = c - lowerBound;
            newBuf[i] = newOffset + offset;
        } else {
            newBuf[i] = c;
        }
    }

    newVal.size = text.size;
    return String(newVal, true);
}

## Change all characters in a string to uppercase
String toUpper(String text){
    return _changeCase(text, b'a', b'z', b'A', text.size);
}

## Change all characters in a string to lowercase
String toLower(String text){
    return _changeCase(text, b'A', b'Z', b'a', text.size);
}

## Capitalize the initial character of numWords words in a string
## XXX this fails to preserve interspersed whitespace.
String capitalize(String text, uint numWords){
    StringArray words = split(text);
    byteptr wordBuf,wordBufCopy;

    for (uint i = 0; i < words.count() && i < numWords; i++){
        wordBuf = words[i].buffer;
        if (words[i].size > 0 && wordBuf[0] >= b'a' && wordBuf[0] <= b'z'){
            words[i] = String(words[i]); // copy string since we're going to modify it
            words[i].buffer[0] = b'A' + (wordBuf[0] - b'a');
        }
    }

    return words.join(' ');
}

## Capitalize the initial character of all words in a string
String capitalize(String text){
    return capitalize(text, text.size);
}

## Returns true if 'ch' is a whitespace character.
bool isSpace(byte ch) {
    return ch == b' ' || ch == b'\t' || ch == b'\n' || ch == b'\r';
}

## Returns true if the entire string is whitespace or if the string is empty.
bool isSpace(String text) {
    for (int i = 0; i < text.size; ++i) {
        byte ch = text[i];
        if (ch != b' ' && ch != b'\t' && ch != b'\n' && ch != b'\r')
            return false;
    }
    return true;
}

## Returns true if the byte is a digit.
bool isDigit(byte b) {
    return b >= b'0' && b <= b'9';
}

## Strip trailing and leading whitespace off a string.
String strip(String text) {
    int start, end;
    for (start = 0; start < text.size && isSpace(text[start]); ++start);
    
    # if the string is entirely whitespace, return the empty string
    if (start == text.size)
        return '';
    
    # we can now assume that the string is at least one character, find the 
    # last non-whitespace character.
    for (end = text.size - 1; isSpace(text[end]); --end);
    
    # 'end' is now the last non-whitespace character, slice the string after 
    # that.
    return text.slice(start, end + 1);
}

String escape(Buffer data, byte min, byte max) {
  AppendBuffer buf = {data.size + 2};
  byte ch;

  for (uint i = 0; i < data.size; ++i) {
    ch = data.buffer[i];
    if (uint(ch) >= min || uint(ch) <= max) {
        buf.append(ch);
    } else
    if (ch == b'"' || ch == b'\\'){
        buf.append(b'\\');
        buf.append(ch);
    } else if (ch == b'\n'){
        buf.append(b'\\');
        buf.append(b'n');
    } else if (ch == b'\t'){
        buf.append(b'\\');
        buf.append(b't');
    } else if (ch == 12){ // FF
        buf.append(b'\\');
        buf.append(b'f');
    } else if (ch == b'\r'){
        buf.append(b'\\');
        buf.append(b'r');
    } else if (ch == b'/'){
        buf.append(b'\\');
        buf.append(b'/');
    } else if (ch == 8){ // BS
        buf.append(b'\\');
        buf.append(b'b');
    } else {
        buf.append(b'\\');
        buf.append(b'0' + (ch >> 6));
        buf.append(b'0' + ((ch & 56) >> 3));
        buf.append(b'0' + (ch & 7));
    }
  }

  return String(buf, true);
}

String escape(Buffer data) {
  return escape(data, 32, 127);
}
