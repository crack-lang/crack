# annotation that generates bindings.
# This currently duplicates the parser logic - rewrite this once the 
# annotation interface supports introspection of compile contexts.

import crack.lang die, free, AppendBuffer;
import crack.io cout, Formatter, StringFormatter, Writer;
import crack.compiler CrackContext, Token;
import crack.exp.file File;
import crack.exp.error err;

@import crack.exp.ann define;
@import crack.exp.cont.treemap GenericTreeMap;
@import crack.exp.cont.array GenericArray, GenericObjArray;

class Func;

class Type {
    String name;
    String __emitName;
    bool initialized;
    
    oper init(String name) : name = name, __emitName = 'type_' + name {}
    oper init(String name, String emitted) :
        name = name,
        __emitName = emitted {
    }
    
    String emit() {
        return __emitName;
    }
    
    bool isBuiltIn() {
        return false;
    }

    void emitInitializer(Formatter out) {
        err.do() `$(this.class.name).emitInitializer() not implemented`;
    }
    
    String getConstCast() { return null; }
}

class Arg {
    String name;
    Type type;

    oper init(Type type, String name) : type = type, name = name {}
}

@GenericObjArray(ArgArray, Arg);
 
class Func {
    Type retType;
    String name;
    ArgArray args;

    oper init(Type retType, String name) :
        retType = retType, 
        name = name,
        args() {
    }
    
    void addArg(Arg arg) {
        args.append(arg);
    }
}

@GenericObjArray(FuncArray, Func);

int cmp(String a, String b) { return a.cmp(b); }
@GenericTreeMap(TypeMap, String, Type);

class BuiltInType : Type {
    String funcName;
    oper init(String name, String funcName) : 
        Type(name), 
        funcName = funcName {
    }
    
    bool isBuiltIn() {
        return true;
    }
    
    void emitInitializer(Formatter out) {
        if (initialized) 
            return;
        out `    crack::ext::Type *$(emit()) = mod->get$(funcName)Type();\n`;
        initialized = true;
    }
}

class ConstType : BuiltInType {
    
    String constCast;
    
    oper init(String name, String funcName, String constCast) :
        BuiltInType(name, funcName),
        constCast = constCast {
    }

    String getConstCast() { return constCast; }
}

class TypeImpl : Type {
    String emitted;
    FuncArray methods;
    ArgArray members = {};
    
    oper init(String name) : Type(name) {}
    oper init(String name, String emitted) : Type(name, emitted) {}

    // class members
    void addMember(Arg member) {
        members.append(member);
    }

   // class methods, emit not implemented
    void addMethod(Arg method) {
        // methods.append(method);
    }

    void emitInitializer(Formatter out) {
        if (initialized)
            return;

        typeVar := emit();
        
        // emit initializer
        out `    crack::ext::Type *$typeVar = mod->addType("$name");\n`;

        // emit member variables
        for (member :in members){
           if (member.type.isBuiltIn()) 
              member.type.emitInitializer(out);
           out `       $typeVar->addInstVar($(member.type.emit()),
                                            "$(member.name)");\n`;
        }
        
        // finish type definition
        out `    $typeVar->finish();\n\n`;
        initialized = true;
    }
}

class SpecializedType : TypeImpl {
    
    Type generic, specializer;
    
    @static String _mangle(String name) {
        # allocate a generous buffer
        AppendBuffer result = {name.size * 2};
        for (uint i = 0; i < name.size; ++i) {
            ch := name.buffer[i];
            if (ch == 95)  # '_'
                result.extend('__');
            else if (ch == 91)
                result.extend('_p');
            else if (ch == 93)
                result.extend('_q');
            else
                result.append(ch);
        }
        
        result.size = result.pos;
        return String(result, true);
    }
    
    # specialized types look like builtins - we don't do the normal type 
    # creation for them, instead we just get specializations for them.
    oper init(String name, Type generic, Type specializer) :
        TypeImpl(name, _mangle(name)),
        generic = generic,
        specializer = specializer {
    }

    void emitInitializer(Formatter out) {
        if (initialized)
            return;

        # make sure that the types we depend on are initialized
        generic.emitInitializer(out);
        specializer.emitInitializer(out);

        typeName := emit();
        out `
    crack::ext::Type *$typeName;
    {
        std::vector<crack::ext::Type *> params(1);
        params[0] = $(specializer.emit());
        $typeName = $(generic.emit())->getSpecialization(params);
    }
`;
    }
}

class GenericType : TypeImpl {
    oper init(String name, String emitted) :
        TypeImpl(name, emitted) {
    }
    
    Type getSpecialization(TypeMap types, Type specializer) {
        
        # construct the specilization name
        StringFormatter fmt = {};
        fmt `$name[$(specializer.name)]`;
        newName := fmt.createString();
        
        # see if there's an existing type, create a new one if not.
        type := types.get(newName);
        if (!type) {
            type = SpecializedType(newName, this, specializer);
            types[newName] = type;
        }

        return type;
    }

    void emitInitializer(Formatter out) {
        if (initialized) return;
        out `
    crack::ext::Type $(emit()) = mod->addType("$name");
`;
    }
}

class ArrayType : GenericType {

    oper init() :
        GenericType('array', 'array') {
    }
    
    void emitInitializer(Formatter out) {
        if (initialized) return;
        out `
    crack::ext::Type *$(emit()) = mod->getType("array");
`;
        initialized = true;
    }
}

class Const {
    Type type;
    String ident, val;

    oper init(Type type, String ident) :
        type = type,
        ident = ident,
        val = ident {
    }

    oper init(Type type, String ident, String val) :
        type = type,
        ident = ident,
        val = val {
    }    
}

class Errors : StringFormatter {
    
    CrackContext ctx;
    Token tok;
    
    oper init(CrackContext ctx, Token tok) : ctx = ctx, tok = tok {}
    oper init(CrackContext ctx) : ctx = ctx {}
    
    oper del() {
        # null terminate
        this `\0`;
        if (!(tok is null))
            ctx.error(tok, createString().buffer);
        else
            ctx.error(createString().buffer);
    }
}

@define setBuiltinType(val, func) {
    name = val;
    types[name] = BuiltInType(name, func);
}

@define setConstType(val, func, cast) {
    name = val;
    types[name] = ConstType(name, func, cast);
}

@define def_join(Iterable) {
    String join(Iterable strings, String sep) {
        
        # figure out how much space we need
        uint total;
        for (elem :in strings)
            total += elem.size + sep.size;
        
        # drop the last separator
        total -= sep.size;
        
        AppendBuffer buf = {total};
        first := true;
        for (elem :in strings) {
        
            # add the separator for everything but the first string.
            if (first)
                first = false;
            else
                buf.extend(sep);

            buf.extend(elem);
        }
        
        return String(buf, true);
    }
}

@GenericObjArray(StringArray, String)
@def_join(StringArray);       
@GenericObjArray(ConstArray, Const);

class ExtensionData {
    String filename;
    TypeMap types;
    FuncArray funcs;
    StringArray module = {};  # module name
    StringArray preamble = {};
    ConstArray consts = {};
    bool inSrcDir;
    
    oper init() : types(), funcs() {
        String name;
        @setBuiltinType('Class', 'Class');
        @setBuiltinType('void', 'Void');
        @setBuiltinType('voidptr', 'Voidptr');
        @setBuiltinType('bool', 'Bool');
        @setBuiltinType('byteptr', 'Byteptr');
        @setBuiltinType('byte', 'Byte');
        @setConstType('int32', 'Int32', 'int');
        @setConstType('int64', 'Int64', 'int64_t');
        @setConstType('uint32', 'Uint32', 'int');
        @setConstType('uint64', 'Uint64', 'int64_t');
        @setConstType('int', 'Int', 'int');
        @setConstType('uint', 'Uint', 'int');
        @setConstType('float32', 'Float32', 'double');
        @setConstType('float64', 'Float64', 'double');
        @setConstType('float', 'Float', 'double');
        
        types['array'] = ArrayType();
    }
    
    Errors error(CrackContext ctx, Token tok) { return Errors(ctx, tok); }
    Errors error(CrackContext ctx) { return Errors(ctx); }

    Type _parseType(CrackContext ctx) {
        tok := ctx.getToken();
        if (!tok.isIdent())
            error(ctx, tok) `Type specifier expected`;
        type := types.get(String(tok.getText()));
        if (!type)
            error(ctx, tok) `Unknown type $(tok.getText())`;
        
        # check for a specializer type
        tok = ctx.getToken();
        Type specializer;
        if (tok.isLBracket()) {
            specializer = _parseType(ctx);
            tok = ctx.getToken();
            if (!tok.isRBracket())
                error(ctx, tok) `Right bracket expected`;
            
            if (!type.class.isSubclass(GenericType))
                error(ctx, tok) `$(type.name) is not a generic type`;
            
            type = GenericType.unsafeCast(type).getSpecialization(types, 
                                                                  specializer
                                                                  );
        } else {
            ctx.putBack(tok);
        }
        
        return type;
    }
        
 
    void _parseFuncDef(CrackContext ctx) {
        retType := _parseType(ctx);
        
        tok := ctx.getToken();
        if (!tok.isIdent())
            error(ctx, tok) `Identifier expected`;
        
        f := Func(retType, String(tok.getText()));
        funcs.append(f);

        if (!(tok = ctx.getToken()).isLParen())
            error(ctx, tok) `Left paren expected`;
        
        tok = ctx.getToken();
        while (!tok.isRParen()) {
            # parse the argument type
            ctx.putBack(tok);
            argType := _parseType(ctx);
            
            # get the arg variable
            tok = ctx.getToken();
            if (!tok.isIdent())
                error(ctx, tok) `argument name expected`;
            
            f.addArg(Arg(argType, String(tok.getText())));
            
            tok = ctx.getToken();
            if (tok.isComma())
                tok = ctx.getToken();
            else if (!tok.isRParen())
                error(ctx, tok) `Comma or right paren expected`;
        }   
    }

    void _parseClassDef(CrackContext ctx) {
        # get the type name.
        tok := ctx.getToken();
        TypeImpl ctype;

        if (!tok.isIdent())
            error(ctx, tok) `Identifier expected after "class" keyword.`;
        
        String className = {tok.getText()};
        
        # get a semicolon or left curly
        tok = ctx.getToken();
        if (tok.isSemi() || tok.isLCurly()){
            ctype = TypeImpl(className);
            types[className] = ctype;
        } else {
            error(ctx, tok) `Semicolon or class definition expected after \
class declaration`;
            return;
        }

        if (tok.isLCurly()) {
            tok = ctx.getToken();
            while (!tok.isRCurly()) {
                # parse the argument type
                ctx.putBack(tok);
                argType := _parseType(ctx);
                
                # get the arg variable
                tok = ctx.getToken();
                if (!tok.isIdent())
                    error(ctx, tok) `argument name expected`;
 
                ctype.addMember(Arg(argType, String(tok.getText())));
                tok = ctx.getToken();
 
                while (tok.isComma()){
                    tok = ctx.getToken();
                    if (!tok.isIdent())
                        error(ctx, tok) `argument name expected`;
 
                    ctype.addMember(Arg(argType, String(tok.getText())));
                    tok = ctx.getToken();
                    if (!tok.isSemi() && !tok.isComma())
                        error(ctx, tok) `Semicolon or comma expected`;
                }

                if (tok.isSemi())
                    tok = ctx.getToken();
                else if (!tok.isRCurly())
                    error(ctx, tok) `Semicolon or right curly brace expected`;
            }
        }
    }

    String _parseString(CrackContext ctx) {
        tok := ctx.getToken();
        if (!tok.isString())
            error(ctx, tok) `Expected string`;
        return String(tok.getText());
    }

    void _parseAnnotation(CrackContext ctx) {
        tok := ctx.getToken();
        if (tok.isIdent()) {
            String ann = {tok.getText()};
            if (ann == 'filename') {
                filename = _parseString(ctx);
            } else if (ann == 'inject') {
                preamble.append(_parseString(ctx));
            } else if (ann == 'crack_internal') {
                inSrcDir = true;
            } else {
                error(ctx, tok) `Unexpected annotation: $ann`;
            }
        } else {
            error(ctx, tok) `Identifier expected after at sign`;
        }
    }

    StringArray _parseExtensionName(CrackContext ctx) {
        StringArray result = {};
        while (true) {
            tok := ctx.getToken();
            if (!tok.isIdent())
                error(ctx, tok) `Expected extension name.`;
            
            result.append(String(tok.getText()));
            tok = ctx.getToken();
            
            if (!tok.isDot()) {
                ctx.putBack(tok);
                break;
            }
        }
        
        return result;
    }
    
    void _parseConst(CrackContext ctx) {
        Type type = _parseType(ctx);
        
        if (!type.getConstCast())
            error(ctx) `$(type.name) is not a valid constant type.`;
        
        while (true) {
            tok := ctx.getToken();
            if (!tok.isIdent())
                error(ctx, tok) `Identifier expected in constant definition`;
            
            ident := String(tok.getText());
            
            tok = ctx.getToken();
            if (tok.isSemi()) {
                consts.append(Const(type, ident));
                break;
            } else if (tok.isComma()) {
                consts.append(Const(type, ident));
                continue;
            }
            
            # expecting assigning to a value
            if (!tok.isAssign())
                error(ctx, tok) `Assignment operator, comma or semicolon \
expected after constant name.`;
            
            tok = ctx.getToken();
            if (!(tok.isIdent() || tok.isString() || tok.isInteger() ||
                  tok.isFloat()
                  )
                )
                error(ctx, tok) `Constant value must be an identifier, number \
or string.`;

            consts.append(Const(type, ident, String(tok.getText())));
            
            tok = ctx.getToken();
            if (tok.isSemi())
                break;
            else if (!tok.isComma())
                error(ctx, tok) `comma or semicolon expected after constant \
definition.`;
        }
    }
 
    void parse(CrackContext ctx) {
        
        # get the extension module
        module = _parseExtensionName(ctx);
        
        # expecting a '{'
        tok := ctx.getToken();
        if (!tok.isLCurly())
            error(ctx, tok) `Opening curly bracket expected`;

        # parse all definitions
        while (true) {
            tok = ctx.getToken();
            
            # check for a class definition
            if (tok.isClass())
                _parseClassDef(ctx);
            else if (tok.isIdent()) {
                if (String(tok.getText()) == 'const') {
                    _parseConst(ctx);
                } else {
                    ctx.putBack(tok);
                    _parseFuncDef(ctx);
                }
            } else if (tok.isRCurly())
                break;
            else if (tok.isSemi())
                ;
            else if (tok.isAnn())
                _parseAnnotation(ctx);
            else
                error(ctx, tok)
                    `expected class, function or right curly bracket.`;
        }
        
    }

    String header(String name) {
        StringFormatter fmt = {};
        pfx := inSrcDir ? '' : 'crack/';
        fmt `"$(pfx)ext/$name.h"`;
        return fmt.createString();
    }

    void emitCode(Writer out) {
        o := Formatter(out);
        
        for (block :in preamble)
            o `$block`;
        
        o `

#include $(header('Module'))
#include $(header('Type'))
#include $(header('Func'))

extern "C"
void $(join(module, '_'))_init(crack::ext::Module *mod) {
    crack::ext::Func *f;
`;
        
        for (kv :in types)
            kv.val.emitInitializer(o);
        
        for (func :in funcs) {
            retTypeRepr := func.retType.emit();
            o `
    f = mod->addFunc($retTypeRepr, "$(func.name)",
                     (void *)$(func.name)
                     );
`;
            for (arg :in func.args)
                o `    f->addArg($(arg.type.emit()), "$(arg.name)");\n`;
        }

        for (c :in consts) {
            cast := c.type.getConstCast();
            o `
    mod->addConstant($(c.type.emit()), "$(c.ident)",
                     static_cast<$cast>($(c.val))
                     );
`;
        }
        
        o `}\n`;
    }

    void emit() {
        # emit all of the code
        cout `emitting $filename\n`;
        out := Formatter(File(filename, 'w'));
        emitCode(out);
    }
}

void generateExtension(CrackContext ctx) {
    ExtensionData ext = {};
    ext.parse(ctx);
    if (!ext.filename)
        ctx.error('no filename specified'.buffer);
    else
        ext.emit();
}
