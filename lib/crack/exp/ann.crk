# Copyright 2010 Google Inc.
# Implements some basic annotations that no one should be without.  Included
# are:
# @define name(arg, ...) { contents }
#   defines a macro with the specified arguments (you can then use the macro 
#   as @name(args...))
# I guess there's currently only one :-)

import crack.io cout, StringFormatter;
import crack.compiler CrackContext, Token;
import crack.container Array, TreeMap;

class UInt {
    uint val;
    
    oper init(uint val0) : val = val0 {}
}

class TokNode {
    TokNode next = null;
    Token tok = null;
    uint argIndex;
    
    oper init(Token tok0) : tok = tok0 {}
    oper init(uint argIndex0) : argIndex = argIndex0 {}
}

## A list of tokens.  These are typically stored in reverse order of the 
## actual order of the tokens so that they can be easily "put back" into the 
## token stream (after putBack() they will be in the correct order once again)
class TokList {
    TokNode first = null, last = null;
    
    void pushHead(TokNode node) {
        if (first) {
            node.next = first;
            first = node;
        } else {
            first = last = node;
        }
    }    
}

class Macro : TokList {
    String name;
    uint argCount;
}

## Annotation to expand a macro.  This expects a Macro instance as user data.
void expand(CrackContext ctx) {
    mac := Macro.unsafeCast(ctx.getUserData());

    # extract the arguments from the following tokens
    tok := ctx.getToken();
    if (!tok.isLParen())
        ctx.error(tok, 'left paren expected in macro expansion'.buffer);
    
    uint nesting = 1;
    argTokList := TokList();
    Array args = {mac.argCount};
    while (true) {
        tok = ctx.getToken();
        if (tok.isLParen()) {
            ++nesting;
        } else if (tok.isRParen()) {
            if (!--nesting)
                break;
        } else if (nesting == 1 && tok.isComma()) {
            args.append(argTokList);
            argTokList = TokList();
        } else {
            argTokList.pushHead(TokNode(tok));
        }
    }
    
    # if we got a non-empty element left over, add it to the list.
    if (argTokList.first)
        args.append(argTokList);
    
    # verify that the number of arguments provided was correct
    if (args.count() != mac.argCount) {
        fmt := StringFormatter();
        fmt `Incorrect number of arguments for macro: expected \
$(mac.argCount), got $(args.count())\0`;
        ctx.error(tok, fmt.createString().buffer);
    }

    # expand the macro
    TokNode node = mac.first;
    while (node) {
        if (!(node.tok is null)) {
            ctx.putBack(node.tok);
        } else {
            # this is an argument: expand the value of the argument.
            argValNode := TokList.cast(args[node.argIndex]).first;
            while (argValNode) {
                ctx.putBack(argValNode.tok);
                argValNode = argValNode.next;
            }
        }
        node = node.next;
    }
}

void define(CrackContext ctx) {
    Macro mac;
    TreeMap args;
    uint index;
    tok := ctx.getToken();
    
    if (!tok.isIdent())
        ctx.error(tok, 'Macro name expected after define.'.buffer);
    mac.name = String(tok.getText());
    
    # parse the '(' that begins the argument list
    tok = ctx.getToken();
    if (!tok.isLParen())
        ctx.error(tok, 'Left paren expected after macro definition'.buffer);
    
    # read all of the arguments
    while (true) {
        tok = ctx.getToken();
        if (tok.isRParen())
            break;
        
        if (!tok.isIdent())
            ctx.error(tok, 'identifier expected'.buffer);

        args[String(tok.getText())] = UInt(index++);
        
        tok = ctx.getToken();
        if (tok.isRParen())
            break;
        else if (!tok.isComma())
            ctx.error('comma or end paren expected in macro def'.buffer);
    }
    mac.argCount = index;
    
    # read the body of the macro
    tok = ctx.getToken();
    if (!tok.isLCurly())
        ctx.error('Expected left bracket'.buffer);

    # read everything until the end bracket
    uint bracketCount = 1;
    while (true) {
        tok = ctx.getToken();
        Object argIndex = null;

        if (tok.isEnd()) {
            ctx.error(
                'End of file before the end of a macro definition'.buffer
            );
        # check for brackets, increment or decrement the bracket count.
        } else if (tok.isRCurly()) {
            if (!--bracketCount)
                break;
        } else if (tok.isLCurly()) {
            ++bracketCount;
        }

        # replace arguments with indices
        else if (tok.isIdent() && 
                 (argIndex = args.get(String(tok.getText())))
                 )
            mac.pushHead(TokNode(UInt.cast(argIndex).val));
        else
            mac.pushHead(TokNode(tok));
    }
    
    # store a new annotation for expanding the macro
    ctx.storeAnnotation(mac.name.buffer, expand, mac);
    mac.oper bind();
}

        
