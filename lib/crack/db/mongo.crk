// Copyright 2013 Conrad Steenberg <conrad.steenberg@gmail.com>
//
//   This Source Code Form is subject to the terms of the Mozilla Public
//   License, v. 2.0. If a copy of the MPL was not distributed with this
//   file, You can obtain one at http://mozilla.org/MPL/2.0/.
//
// Higher level classes from mongo client binding

import crack.lang Buffer, CString;
import crack.time Time;
import crack.ext._mongo
    BSON_BINARY_SUBTYPE_GENERIC, BSON_BINARY_SUBTYPE_FUNCTION,
    BSON_BINARY_SUBTYPE_BINARY, BSON_BINARY_SUBTYPE_UUID,
    BSON_BINARY_SUBTYPE_MD5, BSON_BINARY_SUBTYPE_USER_DEFINED, BSON_TYPE_NONE,
    BSON_TYPE_DOUBLE, BSON_TYPE_STRING, BSON_TYPE_DOCUMENT, BSON_TYPE_ARRAY,
    BSON_TYPE_BINARY, BSON_TYPE_OID, BSON_TYPE_BOOLEAN,
    BSON_TYPE_UTC_DATETIME, BSON_TYPE_NULL, BSON_TYPE_REGEXP,
    BSON_TYPE_JS_CODE, BSON_TYPE_SYMBOL, BSON_TYPE_JS_CODE_W_SCOPE,
    BSON_TYPE_INT32, BSON_TYPE_TIMESTAMP, BSON_TYPE_INT64,
    MONGO_COLLECTION_DEFAULTS, MONGO_COLLECTION_CAPPED,
    MONGO_COLLECTION_CAPPED_MAX, MONGO_COLLECTION_AUTO_INDEX_ID,
    MONGO_COLLECTION_SIZED, MONGO_INDEX_UNIQUE, MONGO_INDEX_DROP_DUPS,
    MONGO_INDEX_BACKGROUND, MONGO_INDEX_SPARSE,

    // Types
    bson, bson_cursor, mongo_connection, mongo_packet, mongo_sync_connection, 
    mongo_sync_cursor, mongo_sync_pool, mongo_sync_pool_connection,

    // Function names
    bson_type_as_string,
    bson_new,
    bson_new_sized,
    bson_new_from_data,
    bson_finish,
    bson_reset,
    bson_free,
    bson_size,
    bson_data,
    bson_validate_key,

    bson_append_string,
    bson_append_double,
    bson_append_document,
    bson_append_array,
    bson_append_binary,
    bson_append_oid,
    bson_append_boolean,
    bson_append_utc_datetime,
    bson_append_null,
    bson_append_regex,

    bson_append_javascript,
    bson_append_symbol,
    bson_append_javascript_w_scope,
    bson_append_int32,
    bson_append_timestamp,
    bson_append_int64,
    bson_cursor_new,
    bson_find,
    bson_cursor_free,
    bson_cursor_next,

    bson_cursor_find_next,
    bson_cursor_find,
    bson_cursor_type,
    bson_cursor_type_as_string,
    bson_cursor_key,
    bson_cursor_get_string,
    bson_cursor_get_double,
    bson_cursor_get_document,
    bson_cursor_get_array,
    bson_cursor_get_oid,

    bson_cursor_get_boolean,
    bson_cursor_get_utc_datetime,
    bson_cursor_get_javascript,
    bson_cursor_get_symbol,
    bson_cursor_get_int32,
    bson_cursor_get_timestamp,
    bson_cursor_get_int64,
    mongo_sync_connect,
    mongo_sync_conn_seed_add,
    mongo_sync_reconnect,

    mongo_sync_disconnect,
    mongo_sync_conn_get_slaveok,
    mongo_sync_conn_set_slaveok,
    mongo_sync_conn_get_safe_mode,
    mongo_sync_conn_set_safe_mode,
    mongo_sync_conn_get_auto_reconnect,
    mongo_sync_conn_set_auto_reconnect,
    mongo_sync_conn_get_max_insert_size,
    mongo_sync_conn_set_max_insert_size,
    mongo_sync_cmd_update,

    mongo_sync_cmd_insert,
    mongo_sync_cmd_insert_n,
    mongo_sync_cmd_query,
    mongo_sync_cmd_get_more,
    mongo_sync_cmd_delete,
    mongo_sync_cmd_custom,
    mongo_sync_cmd_count,
    mongo_sync_cmd_exists,
    mongo_sync_cmd_drop,
    mongo_sync_cmd_reset_error,
    mongo_sync_cmd_is_master,

    mongo_sync_cmd_ping,
    mongo_sync_cmd_user_add,
    mongo_sync_cmd_user_remove,
    mongo_sync_cmd_authenticate,
    mongo_sync_cmd_index_create,
    mongo_sync_cmd_index_drop,
    mongo_sync_cmd_index_drop_all,
    mongo_wire_packet_new,
    mongo_wire_packet_free,
    mongo_sync_cursor_new,

    mongo_sync_cursor_next,
    mongo_sync_cursor_get_data,
    mongo_sync_cursor_free,
    mongo_sync_pool_new,
    mongo_sync_pool_free,
    mongo_sync_pool_pick,
    mongo_sync_pool_return,
    mongo_util_oid_init,
    mongo_util_oid_new,
    mongo_util_oid_new_with_time,

    mongo_util_oid_as_string,
    mongo_connect,
    mongo_disconnect,
    mongo_connection_get_requestid,
    mongo_connection_set_timeout;

int MONGO_CONN_LOCAL = -1;
class BSON;

class BSON {
    bson _b;

    // Create a new BSON object.
    oper init() : _b = bson_new() {}

    // Copy constructor
    oper init(bson b) : _b = b {
        
    }

    // Create a new BSON object, preallocating a given amount of space.
    oper init(int32 size) : _b = bson_new_sized(size) {}

    // Create a BSON object from existing data.
    
    oper init(byteptr data, int32 size) :
              _b = bson_new_from_data(data, size) {
    }
    
    // Finish a BSON object.
    bool finish() {
        return bson_finish(_b);
    }

    // Reset a BSON object.
    bool reset() {
        return bson_reset(_b);
    }
    
    // Free the memory associated with a BSON object.
    oper del() {
        if (!(_b is null)) bson_free(_b);
    }

    // Return the size of a finished BSON object.
    int32 size() {
        return bson_size(_b);
    }

    // Return the raw bytestream form of the BSON object.
    Buffer data() {
        return Buffer(bson_data(_b), uint(bson_size(_b)));
    }

    bson bson() {
        return _b;
    }

    // Validate a BSON key.
    @static
    bool validateKey(CString key, bool forbid_dots, bool no_dollar) {
        return bson_validate_key(key.buffer, forbid_dots, no_dollar);
    }

    // Append API --------------------------------------------------------------

    // Append a string to a BSON object.
    @final bool appendString(CString name, Buffer val) {
        return bson_append_string(_b, name.buffer, val.buffer,
                                  int32(val.size));
    }

    // Append a BSON document to a BSON object.
    @final bool appendDocument(CString name, BSON doc) {
        return bson_append_document(_b, name.buffer, doc.bson());
    }

    // Append a BSON array to a BSON object.
    @final bool appendArray(CString name, BSON arr) {
        return bson_append_array(_b, name.buffer, arr.bson());
    }

    // Append a BSON binary blob to a BSON object.
    @final bool appendBinary(CString name, int subtype, Buffer data) {
        return bson_append_binary(_b, name.buffer, subtype, data.buffer,
                                  int32(data.size));
    }

    // Append an ObjectID to a BSON object.
    @final bool appendOID(CString name, Buffer oid) {
        if (oid.size != 12) return false;
        return bson_append_oid(_b, name.buffer, oid.buffer);
    }

    // Append a boolean to a BSON object.
    bool appendBool(CString name, bool value) {
        return bson_append_boolean(_b, name.buffer, value);
    }

    // Append an UTC datetime to a BSON object.
    bool appendUTCDateTime(CString name, int64 ts) {
        return bson_append_utc_datetime(_b, name.buffer, ts);
    }

    // Append an UTC datetime to a BSON object.
    bool appendUTCDateTime(CString name, Time ts) {
        return bson_append_utc_datetime(_b, name.buffer,
                int64(ts.secs)*1000+int64(ts.nsecs)/1000000);
    }

    // Append a NULL value to a BSON object.
    bool appendNull(CString name) {
        return bson_append_null(_b, name.buffer);
    }

    // Append a regexp object to a BSON object.
    bool appendRegex(CString name, CString regexp, CString options) {
        return bson_append_regex(_b, name.buffer, regexp.buffer,
                                 options.buffer);
    }

    // Append Javascript code to a BSON object.
    bool appendJavascript(CString name, Buffer js) {
        return bson_append_javascript(_b, name.buffer, js.buffer,
                                      int32(js.size));
    }

    // Append a symbol to a BSON object.
    bool appendSymbol(CString name, Buffer symbol) {
        return bson_append_symbol(_b, name.buffer, symbol.buffer,
                                  int32(symbol.size));
    }

    // Append Javascript code(with scope) to a BSON object.
    bool appendJavascriptScope(CString name, Buffer js, BSON scope) {
        return bson_append_javascript_w_scope(_b, name.buffer, js.buffer,
                                              int32(js.size), scope.bson());
    }

    // Append a double to a BSON object.
    bool appendFloat64(CString name, float64 d) {
        return bson_append_double(_b, name.buffer, d);
    }

    // Append a 32-bit integer to a BSON object.
    bool appendInt32(CString name, int32 i) {
        return bson_append_int32(_b, name.buffer, i);
    }

    // Append a timestamp to a BSON object.
    bool appendTimeStamp(CString name, int64 ts) {
        return bson_append_timestamp(_b, name.buffer, ts);
    }

    // Append a 64-bit integer to a BSON object.
    bool appendInt64(CString name, int64 i) {
        return bson_append_int64(_b, name.buffer, i);
    }
}

class BSONCursor {
    bson_cursor _c;
    bson _b;

    // Create  cursor positioned at the beginning of the document
    oper init(BSON b) : _b = b.bson(),
                        _c = bson_cursor_new(b.bson()) {
    }

    // Create a new cursor positioned at a given key.
    oper init(BSON b, CString name) : _b = b.bson(), 
        _c = bson_find(_b, name.buffer) {
    }

    // Delete a cursor, and free up all resources used by it.
    oper del() {
        bson_cursor_free(_c);
    }

    // Position the cursor to the next key.
    bool next() {
        return bson_cursor_next(_c);
    }

    // Move the cursor to a given key, past the current one.
    bool findNext(CString name) {
        return bson_cursor_find_next(_c, name.buffer);
    }

    // Move the cursor to a given key.
    bool find(CString name) {
        return bson_cursor_find(_c, name.buffer);
    }

    // Determine the type of the current element.
    int type() {
        return bson_cursor_type(_c);
    }

    // Retrieve the type of the current element, as string.
    CString typeString(){
        return CString(bson_cursor_type_as_string(_c), false);
    }

    // Determine the name of the current elements key.
    CString key() {
        return CString(bson_cursor_key(_c), false);
    }
    
    // Get the value stored at the cursor, as string.
    CString getString() {
        return CString(bson_cursor_get_string(_c), false);
    }

    // Get the value stored at the cursor, as a double.
    float64 getFloat64() {
        return bson_cursor_get_double(_c);
    }

    // Get the value stored at the cursor, as a BSON document.
    BSON getDocument() {
        return BSON(bson_cursor_get_document(_c));
    }

    // Get the value stored at the cursor, as a BSON array.
    BSON getArray() {
        return BSON(bson_cursor_get_array(_c));
    }

    // Get the value stored at the cursor, as an ObjectID.
    CString getOID() {
        return CString(bson_cursor_get_oid(_c), false);
    }

    // Get the value stored at the cursor, as a boolean.
    bool getBool() {
        return bson_cursor_get_boolean(_c);
    }

    // Get the value stored at the cursor, as an UTC datetime.
    Time getUTCDateTime(){
        millisecs := bson_cursor_get_utc_datetime(_c);
        s := millisecs/1000;
        return Time(int32(s), int32((millisecs - s*1000)*1000000));
    }

    // Get the value stored at the cursor, as javascript code.
    CString getJavascript() {
         return CString(bson_cursor_get_javascript(_c),false);
    }

    // Get the value stored at the cursor, as a symbol.
    CString getSymbol(){
        return CString(bson_cursor_get_symbol(_c), false);
    }

    // Get the value stored at the cursor, as a 32-bit integer.
    int32 getInt32() {
        return bson_cursor_get_int32(_c);
    }

    // Get the value stored at the cursor, as a timestamp.
    int64 getTimeStamp() {
        return bson_cursor_get_timestamp(_c);
    }

    // Get the value stored at the cursor, as a 64-bit integer.     
    int64 getInt64() {
        return bson_cursor_get_int64(_c);
    }
}

class MongoSync;

class MongoSync {

    mongo_sync_connection _m;

    // Synchronously connect to a MongoDB server.
    oper init(CString address, int port, bool slaveOK) :
            _m = mongo_sync_connect(address.buffer, port, slaveOK) {
    }

    mongo_sync_connection mongo() {
        return _m;
    }

    oper init (mongo_sync_connection m) : _m = m {}

    // Add a seed to an existing MongoDB connection.
    bool addSeed(CString host, int port) {
        return mongo_sync_conn_seed_add(_m, host.buffer, port);
    }

    // Attempt to connect to another member of a replica set.
    MongoSync reconnect(bool forceMaster) {
        return MongoSync(mongo_sync_reconnect(_m, forceMaster));
    }

    // Close and free a synchronous MongoDB connection.
    oper del(){
        if (!(_m is null)) mongo_sync_disconnect(_m);
        _m = null;
    }

    // Retrieve the state of the SLAVE_OK flag from a sync connection.
    bool getSlaveOK() {
        return  mongo_sync_conn_get_slaveok(_m);
    }

    // Set the SLAVE_OK flag on a sync connection.
    bool setSlaveOK(bool slaveOK) {
        return mongo_sync_conn_set_slaveok(_m, slaveOK);
    }

    // Retrieve the state of the safe mode flag from a sync connection.
    bool getSafeMode() {
        return mongo_sync_conn_get_safe_mode(_m);
    }

    // Set the safe mode flag on a sync connection.
    bool setSafeMode(bool safeMode) {
        return mongo_sync_conn_set_safe_mode(_m, safeMode);
    }

    // Get the state of the auto-reconnect flag from a sync connection.
    bool getAutoReconnect() {
        return mongo_sync_conn_get_auto_reconnect(_m);
    }

    // Set the state of the auto-reconnect flag on a sync connection.
    bool setAutoReconnect(bool autoReconnect) {
        return mongo_sync_conn_set_auto_reconnect(_m, autoReconnect);
    }

    // Get the maximum size of a bulk insert package.
    int32 getMaxInsertSize() {
        return mongo_sync_conn_get_max_insert_size(_m);
    }

    // Set the maximum size of a bulk insert package.
    bool setMaxInsertSize(int32 maxSize) {
        return mongo_sync_conn_set_max_insert_size(_m, maxSize);
    }

    // Command methods
    // Send an update command to MongoDB.
    bool update(CString ns, int32 flags, BSON selector, BSON update) {
        return mongo_sync_cmd_update(_m, ns.buffer, flags,
                                     selector.bson(), update.bson());
    }

    // Send an insert command to MongoDB. TODO bind
    bool insert(CString ns, BSON doc) {
        return mongo_sync_cmd_insert(_m, ns.buffer, doc.bson());
    }

    // Send an insert command to MongoDB.
    bool insertN(CString ns, int32 n, BSON docs) {
        return mongo_sync_cmd_insert_n(_m, ns.buffer, n, docs.bson());
    }

    // Send a query command to MongoDB. TODO add
    // mongo_packet mongo_sync_cmd_query(mongo_sync_connection conn, byteptr ns,
    //                                   int32 flags, int32 skip, int32 ret,
    //                                   bson query, bson sel);

    // Send a get more command to MongoDB. TODO add
    // mongo_packet mongo_sync_cmd_get_more(mongo_sync_connection conn, byteptr ns,
    //                                       int32 ret, int64 cursor_id);

    // Send a delete command to MongoDB.
    bool delete(CString ns, int32 flags, BSON sel) {
        return mongo_sync_cmd_delete(_m, ns.buffer, flags, sel.bson());
    }

    // Send a kill_cursors command to MongoDB. TODO bind
    // bool mongo_sync_cmd_kill_cursors(mongo_sync_connection conn, int32 n,...);

    // Send a custom command to MongoDB. TODO add
    // mongo_packet mongo_sync_cmd_custom(mongo_sync_connection conn, byteptr db,
    //                                    bson command);

    // Send a count() command to MongoDB.
    float64 count(CString db, CString coll, BSON query) {
        return mongo_sync_cmd_count(_m, db.buffer, coll.buffer, query.bson());
    }

    // Create a new MongoDB collection. TODO bind
    // bool mongo_sync_cmd_create(mongo_sync_connection conn, byteptr db,
    //                            byteptr coll, int flags,...);

    // Check whether a collection exists in MongoDB.
    BSON exists(CString db, CString coll) {
        return BSON(mongo_sync_cmd_exists(_m, db.buffer, coll.buffer));
    }

    // Send a drop() command to MongoDB.
    bool drop(CString db, CString coll) {
        return mongo_sync_cmd_drop(_m, db.buffer, coll.buffer);
    }

    // Get the last error from MongoDB. TODO wrap
    //  bool mongo_sync_cmd_get_last_error(mongo_sync_connection conn, byteptr db,
    //                                      array[byteptr] error);

    // Reset the last error variable in MongoDB.
    bool resetError(CString db) {
        return mongo_sync_cmd_reset_error(_m, db.buffer);
    }

    // Check whether the current node is the master.
    bool isMaster() {
        return mongo_sync_cmd_is_master(_m);
    }

    // Send a PING command to MongoDB.
    bool ping() {
        return mongo_sync_cmd_ping(_m);
    }

    // Add a user to MongoDB.
    bool addUser(CString db, CString user, CString pw) {
        return mongo_sync_cmd_user_add(_m, db.buffer, user.buffer, pw.buffer);
    }

    // Remove a user from MongoDB.
    bool removeUser(CString db, CString user) {
        return mongo_sync_cmd_user_remove(_m, db.buffer, user.buffer);
    }

    // Authenticate a user with MongoDB.
    bool authUser(CString db, CString user, CString pw) {
        return mongo_sync_cmd_authenticate(_m, db.buffer, user.buffer, pw.buffer);
    }

    // Create an index.
    bool createIndex(CString ns, BSON key, int options) {
        return mongo_sync_cmd_index_create(_m, ns.buffer, key.bson(), options);
    }

    // Drop an index.
    bool dropIndex(CString ns, BSON key) {
        return mongo_sync_cmd_index_drop(_m, ns.buffer, key.bson());
    }

    // Drop all indexes from a namespace.
    bool dropIndexAll(CString ns) {
        return mongo_sync_cmd_index_drop_all(_m, ns.buffer);
    }
}
