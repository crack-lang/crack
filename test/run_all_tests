#!/bin/bash

rc=0

function test_output {
    text="$1"
    script="$2"
    expected="$3"
    
    echo -n "$text..."
    if [ "$(echo $script | ./crack - 2>&1)" = "$expected" ]; then
        echo ok
    else
        echo FAILED
        rc=1
    fi
}
        

test_output "hello world" 'puts("hello world")' 'hello world'
test_output "semicolon terminated" 'puts("hello world");' 'hello world'
test_output "variable assignment" 'byteptr d = "abcd"; puts(d);' 'abcd'
test_output "simple if" 'if (1) puts("abcd");' 'abcd'
test_output "block if" 'if (1) { puts("abcd"); }' 'abcd'
test_output "simple if/else" 'if (1) puts("abcd"); else puts("efgh");' 'abcd'
test_output "simple negative if/else" \
    'if (0) puts("abcd"); else puts("efgh");' 'efgh'
test_output 'block if/else' \
    'if (1) { puts("abcd"); } else { puts("efgh"); }' 'abcd'
test_output 'negative block if/else' \
    'if (0) { puts("abcd"); } else { puts("efgh"); }' 'efgh'
test_output 'function with no args' \
    'void func() { puts("abcd"); } func()' "abcd"
test_output 'double terminal "if"' \
    'int32 function(int32 val) { if (val) return val; else return 0; } 
     printint(function(1)); printint(function(0));' \
     10
test_output 'simple addition' \
    'printint(1 + 2)' '3'
test_output 'pass 2 args, return 1' \
    'int32 f(int32 a, byteptr b) { return a; } printint(f(10, "xx"))' \
    '10'
test_output 'void func with explicit return' \
    'void f() { return; } f(); puts("abcd");' 'abcd'
test_output 'returning void from non-void func' \
    'int32 f() { return; }' \
    'ParseError: <stdin>:1: Missing return expression for function returning'\
' int32'
test_output 'invalid return types' \
    'void f() {} int32 g() { return f(); }' \
    'ParseError: <stdin>:1: Invalid return type void for function returning '\
'int32'
test_output 'return in module scope' \
    'return' \
    'ParseError: <stdin>:2: Return statement not allowed in module scope' \

test_output 'simple class definition' 'class Foo {};' ''
test_output 'class with base class' 'class Base {}; class Foo : Base {};' ''
# this was shabby to begin with, restore this and more tests when we get real 
# multiple inheritence working.
#test_output 'class with base classes' 'class Foo : int32, byteptr {};' ''
test_output 'bad class definition' 'class Foo xxx;' \
    'ParseError: <stdin>:1: token xxx was not expected at this time, '\
'expected colon or opening brace.'
test_output 'class with nested def' 'class Foo { int32 val; }' ''
test_output 'nested classes' 'class Foo { class Bar {}; }' ''
test_output 'bad type for member function' \
    'class Foo { xxx f() {} };' \
    'ParseError: <stdin>:1: xxx is not a type.'
test_output 'the "define" (":=") operator' \
    'x := 1234; printint(x)' \
    '1234'
test_output 'basic methods' \
    'class Foo { void p(byteptr data) { puts(data); } }; Foo f; f.p("abcd");' \
    'abcd'

test_output 'instance variables' \
    'class Foo {
        int32 val; void set() {val = 100;} int32 get() {return val;}
    };
    Foo x; x.set(); printint(x.get());
    x.val = 200; printint(x.val);' \
    '100200'

test_output 'implicit this' \
    'class Foo { int32 a; void g() { printint(a); }
                 void f() { a = 100; g(); } 
                 };
     Foo foo; foo.f();' \
     '100'

test_output 'explicit this' \
    'class Foo {
        int32 a;
        void g() { printint(this.a); }
        void f() { this.a = 100; this.g(); }
     };
     Foo foo; foo.f();' \
     '100'

test_output 'bad func names' \
    'class Foo { void f() { this.g(); }};' \
    'ParseError: <stdin>:1: No method exists matching g with these argument '\
'types.'

test_output 'using a classname with its definition' \
    'class C { void out() { puts("abcd"); } 
               C self() { return this; } }; C c; c.self().out();' \
    'abcd'

test_output 'external references of base inst vars' \
    'class A { int32 v; }; class B : A {}; B b; b.v = 100; printint(b.v);' \
    '100'

test_output 'internal references of base class inst vars' \
    'class A { int32 val; };
    class B : A { void init() { val = 100; } int32 f() { return val; } };
    B b; b.init(); printint(b.f());' \
    100

c='class A { int32 s; void i(int32 s0) {s=s0} 
             void release() {printint(s)} };'

test_output 'simple scope release' \
    "$c void func() { A a; a.i(2); printint(1)} func()" \
    12

test_output 'release on return void' \
    "$c void func() { A a; a.i(2); printint(1); return } func()" \
    12

test_output 'release on return expr' \
    "$c int32 func() { A a; a.i(2); printint(1); return 0} func()" \
    12

f="void func(int32 val) { A a; a.i(5); printint(1); 
                          if (val) { A b; b.i(4); printint(2); return; }
                          printint(3); }"
test_output 'premature return in nested context' \
    "$c $f func(1)" \
    1245

test_output 'premature return bypassing nested context' \
    "$c $f func(0)" \
    135

test_output 'explicit default constructor' \
    'class A { int32 val; void init() { val = 100; } };
     A a; printint(a.val);' \
    100

test_output 'implicit default constructor' \
    'class A { int32 val; }; A a; printint(a.val);' \
    0

test_output 'integer comparison operators' \
    'if (0 == 0) printint(1); else printint(0);
     if (1 == 0) printint(0); else printint(1);
     if (0 != 0) printint(0); else printint(1);
     if (0 != 1) printint(1); else printint(0);
     if (1 > 0) printint(1); else printint(0);
     if (1 > 1) printint(0); else printint(1);
     if (0 < 1) printint(1); else printint(0);
     if (1 < 1) printint(0); else printint(1);
     if (1 >= 0) printint(1); else printint(0);
     if (1 >= 1) printint(1); else printint(0);
     if (1 >= 2) printint(0); else printint(1);
     if (0 <= 1) printint(1); else printint(0);' \
     111111111111

test_output 'implicit conversion from int to bool in condition' \
    'if (1) puts("yes"); if (0) puts("no");' \
    yes

exit $rc
