# Script to reformat crack code to the standard style.  This currently only
# works for blocks of import statements.
#
# Copyright 2013 Google Inc.
#
#   This Source Code Form is subject to the terms of the Mozilla Public
#   License, v. 2.0. If a copy of the MPL was not distributed with this
#   file, You can obtain one at http://mozilla.org/MPL/2.0/.
#

import crack.ascii isDigit, isSpace, strip, wsplit;
import crack.cont.array Array;
import crack.cont.treemap TreeMap;
import crack.io cerr, cin, cout, readAll, Formatter, FStr, Reader;
import crack.io.readers LineReader;
import crack.lang AppendBuffer, Exception;
import crack.math min;
import crack.regex Regex;
import crack.strutil StringArray;

@import crack.ann cvars, struct, SCOPE_NAME;

# This is currently just a hack.  It recognizes import statements, reorders
# and reformats them.

importRx := Regex(r'\s*import\s+(\S+)\s+(.*)');
varRx := Regex(r'[a-z].*');
constRx := Regex(r'[A-Z_]+[,;]?$');

int cmpi(String a, String b) {
    int i;
    for (i = 0; i < a.size; ++i) {
        if (i >= b.size)
            return a.buffer[i];

        # case insensitize the current characters.
        int ac = a.buffer[i];
        ac = (ac >= b'a' && ac < b'z') ? ac - 32 : ac;
        int bc = b.buffer[i];
        bc = (bc >= b'a' && ac < b'z') ? bc - 32 : bc;

        diff := ac - bc;
        if (diff)
            return diff;
    }

    return (i < b.size) ? -int(b[i]) : 0;
}

byte normalize(byte val) {
    return val >= b'a' && val <= b'z' ? val - 32 : val;
}

## Byte comparison (since crack's is broken!)
int bcmp(byte a, byte b) {
    return a > b ? 1 : (b > a ? -1 : 0);
}

## Case insensitive string comparison.
int icmp(String a, String b) {

    # Short circuit checks to protect us from null dereferences.
    if (a is b)
        return 0;
    else if (b is null)
        return 1;
    else if (a is null)
        return -1;

    for (int i = 0; i < min(a.size, b.size); ++i) {
        if (rc := bcmp(normalize(a[i]), normalize(b[i])))
            return rc;
    }

    if (a.size > b.size)
        return 1;
    else if (a.size < b.size)
        return -1;
    else
        return 0;
}

## Tracks information on a single imported symbol.
class Symbol {
    @cvars {
        ## Original name of the symbol in its own module.
        String name;

        ## Local context alias (name it will be imported under).  Null if the
        ## symbol is not aliased
        String aliasName;
    }

    void formatTo(Formatter out) {
        if (aliasName)
            out `$aliasName = $name`;
        else
            out `$name`;
    }

    ## The name that the symbol is sorted by.
    String oper .sortName() {
        return aliasName ? aliasName : name;
    }

    ## Compare so we sort, cas insensitive, first by name and then alias
    ## (making names imported under multiple aliases more visible).  Also
    ## incorporate sorting rules (methods/vars first, then classes, then
    ## constants).
    int cmp(Symbol other) {
        return icmp(sortName, other.sortName);
    }

    int cmp(Object other) {
        if (o := Symbol.cast(other))
            return cmp(o);
        else
            return Object.cmp(other);
    }
}

class Import {
    String moduleName;
    Array[Symbol] imports = {};

    oper init(String moduleName) : moduleName = moduleName {}

    ## Sorts the names that are imported.
    void sortNames() {
        Array[Symbol] vars = {}, classes = {}, constants = {};
        for (sym :in imports) {
            if (varRx.match(sym.name))
                vars.append(sym);
            else if (constRx.match(sym.name))
                constants.append(sym);
            else
                classes.append(sym);
        }
        vars.sort();
        classes.sort();
        constants.sort();
        imports = vars;
        imports.extend(classes);
        imports.extend(constants);
    }

    void format(Formatter out) {
        beginning := FStr() `import $(moduleName)`;
        out.write(beginning);
        count := beginning.size;
        bool first = true;
        for (imp :in imports) {
            if (!first)
                out `,`;
            else
                first = false;
            impText := FStr() `$imp`;
            if (count + impText.size + 2 >= 80) {
                out `\n    $imp`;
                count = 4 + impText.size;
            } else {
                out ` $imp`;
                count += impText.size + 2;
            }
        }
        out `;\n`;
    }

    void addSymbol(String name, String aliased) {
        newSym := aliased ? Symbol(aliased, name) : Symbol(name, null);

        # Ignore it if we've already got it.
        for (sym :in imports) {
            if (sym == newSym)
                return;
        }
        imports.append(newSym);
    }
}

const int
    TOK_IDENT = 0,
    TOK_COMMA = 1,
    TOK_SEMI = 2,
    TOK_EQUAL = 3,
    TOK_PERIOD = 4,
    TOK_IMPORT = 5,
    TOK_EOF = 999;

const int
    ST_BASE = 0,
    ST_IDENT = 1;

class Token {
    @cvars { int type; String text; }

    void formatTo(Formatter out) {
        out `Token($type:$text)`;
    }
}

class MiniToker {
    int pos;
    @cvars { String data; }

    Token __makeIdent(int start, bool atEnd) {

        # If we're not at the end, back up one under the assumption that we've
        # just read a character that isn't part of the identifier.
        if (!atEnd)
            --pos;

        text := data.slice(start, pos);
        if (text == 'import')
            return Token(TOK_IMPORT, 'import');
        else
            return Token(TOK_IDENT, text);
    }

    Token getNext() {
        int start = pos;
        int state;
        while (true) {
            if (pos == data.size) {
                if (state == ST_IDENT)
                    return __makeIdent(start, true);
                else
                    return Token(TOK_EOF, '');
            }

            byte ch = data[pos++];

            if (isSpace(ch)) {
                if (state == ST_IDENT)
                    return __makeIdent(start, false);
                ++start;
                continue;
            }

            if (state == ST_BASE) {
                if (ch == b'.')
                    return Token(TOK_PERIOD, '.');
                else if (ch == b',')
                    return Token(TOK_COMMA, ',');
                else if (ch == b';')
                    return Token(TOK_SEMI, ';');
                else if (ch == b'=')
                    return Token(TOK_EQUAL, '=');
                else
                    state = ST_IDENT;
            } else if (state == ST_IDENT) {
                if (!(ch >= b'A' && ch <= b'Z' ||
                      ch >= b'a' && ch <= b'z' ||
                      isDigit(ch) ||
                      ch == b'_'
                      )
                    )
                    return __makeIdent(start, false);
            } else {
                throw Exception(FStr() `Invalid state: $state`);
            }
        }

        return null;
    }
}

const int
    P_BASE = 0,
    P_BEGIN_MOD = 1,
    P_MOD_IDENT = 2,
    P_MOD_POST_IDENT = 3,
    P_POST_VAR = 4,
    P_POST_EQ = 5,
    P_POST_COMMA = 6,
    P_END = 7;

void format(Formatter out, Reader src) {
    Import lastImport;
    importStatements := TreeMap[String, Import]();
    bool passedImports;

    toker := MiniToker(readAll(src));
    while (true) {
        tok := toker.getNext();
        if (tok.type == TOK_IMPORT) {
            # Parse the module name.
            AppendBuffer moduleNameBuf = {32};
            tok = toker.getNext();
            if (tok.type == TOK_PERIOD) {
                moduleNameBuf.extend(tok.text);
                tok = toker.getNext();
            }
            while (true) {
                if (tok.type != TOK_IDENT) {
                    throw Exception(
                        FStr() `Invalid token in module name: $(tok.text)`
                    );
                }
                moduleNameBuf.extend(tok.text);
                tok = toker.getNext();
                if (tok.type != TOK_PERIOD)
                    break;
                moduleNameBuf.append(b'.');
                tok = toker.getNext();
            }

            moduleName := String(moduleNameBuf, true);

            # We want relative imports (beginning with a dot) to sort after
            # absolute imports, so tack a \xff on the beginning of those keys.
            # In fact, it is possible for an identifier to begin with \xff in
            # crack, but it is an obscure enough case for us to ignore.
            keyName := moduleName.startsWith('.') ? '\xff' + moduleName :
                                                    moduleName;

            if (mod := importStatements.get(keyName))
                lastImport = mod;
            else
                importStatements[keyName] = lastImport = Import(moduleName);

            # Parse the imports.
            while (tok.type != TOK_SEMI) {
                if (tok.type != TOK_IDENT)
                    throw Exception(
                        FStr() `Expected identifier, got $(tok.text)`
                    );
                String word = tok.text, aliased;

                tok = toker.getNext();
                if (tok.type == TOK_EQUAL) {
                    tok = toker.getNext();
                    if (tok.type != TOK_IDENT)
                        throw Exception(
                            FStr() `Identifier expected, got $(tok.text)`
                        );
                    aliased = tok.text;
                    tok = toker.getNext();
                }

                # Check for semicolon or comma.
                if (tok.type == TOK_COMMA)
                    tok = toker.getNext();
                else if (tok.type != TOK_SEMI)
                    throw Exception(FStr() `Comma or semicolon expected.`);

                lastImport.addSymbol(word, aliased);
            }
        } else {
            # we got a non-import line, emit the imports.
            for (item :in importStatements) {
                item.val.sortNames();
                item.val.format(out);
            }
            importStatements.clear();

            if (tok.type == TOK_EOF)
                break;
        }
    }

    if (importStatements) {
        for (item :in importStatements) {
            item.val.sortNames();
            item.val.format(out);
        }
    }
}

if (@SCOPE_NAME == '.main')
    format(cout, cin);
