
# overriden definitions in the same context should be an error
int32 a;
int32 a;

# overridden definitions should issue a warning
int32 x;
if (1) { int32 x; }

# duplicate function names in the same context should issue an error
void func() {}
void func() {}

# duplicate function names in different contexts should issue a warning
void func() {
    void func() {}
}

# assignment to a function argument should be legal.
void func(int32 a) {
    a = 100;
}

# void variable definitions should error
void a;

# does this really make any sense?  It's currently legal.
void returnsVoid() {}
void returnsOther() { return returnsVoid(); }


# these are tests that I've done at some point with interesting results and 
# should be added to the general test suite

# Tests that local vars in a loop (LLVM allocas) do not overrun the stack.
# Blocks in a function caused problems because of the order of deletion of 
# ref-counted pointers.
void foo() {
    while (1) {
        byteptr str = 'test';
        puts(str);
    }
}
foo();

void global() { }
class Foo {
    void f() { this.global(); }  // should error
};