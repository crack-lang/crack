
# overriden definitions in the same context should be an error
int32 a;
int32 a;

# overridden definitions should issue a warning
int32 x;
if (1) { int32 x; }

# duplicate function names in the same context should issue an error
void func() {}
void func() {}

# duplicate function names in different contexts should issue a warning
void func() {
    void func() {}
}

# assignment to a function argument should be legal.
void func(int32 a) {
    a = 100;
}

# void variable definitions should error
void a;

# does this really make any sense?  It's currently legal.
void returnsVoid() {}
void returnsOther() { return returnsVoid(); }


# these are tests that I've done at some point with interesting results and 
# should be added to the general test suite

# Tests that local vars in a loop (LLVM allocas) do not overrun the stack.
# Blocks in a function caused problems because of the order of deletion of 
# ref-counted pointers.
void foo() {
    while (1) {
        byteptr str = 'test';
        puts(str);
    }
}
foo();

void global() { }
class Foo {
    void f() { this.global(); }  // should error
};

# currently fails because we generate unreachable code after the else but 
# don't give it a return statement.  Need to stop generating unreachable code.
int32 foo(int32 x) { if (x) return 1; else return 0; puts("test"); }

# this snippet will currently print "true" instead of 100, because implicit 
# conversion means f(bool) hides f(int32).  The overloader should reorder the 
# methods so the least general is called first.  I'm not sure what it should 
# do for f(bool, int32) vs f(int32, bool).  It should probably not do
# reordering and just not attempt conversions unless exact matches fail.
void f(int32 v) {printint(v);}
void f(bool b) {if (b) puts("true"); else puts("false")}
f(100);

# this currently doesn't work because 'A' gets treated like a definition
class A { };
A();

# should not be able to derive a class from an incomplete class
class A {
    class B : A {}
};