// A test suite for crack
// Copyright 2010-2011 Shannon Weyrick <weyrick@mozek.us>

import crack.io cout, cerr, Formatter, Writer, StringWriter, StringFormatter, FStr;
import crack.sys argv, exit;
import crack.exp.dir Directory;
import crack.exp.file File, FileInfo;
import crack.exp.regex Regex;
import crack.exp.process Process;
import crack.exp.cmdline CmdOptions, Option, CMD_STR, CMD_INT, CMD_BOOL;
import crack.cont.hashmap HashMap;
import crack.cont.array Array;
import crack.cont.priorityqueue PriorityQueue;
import crack.strutil StringArray, split;

import testdata TestData;
import builders BuilderTestHarness, CrackBuilderDef, builderDefList;
import config config, T_INIT, T_RUNNING, T_FINISHED;

// represent single test template
// parse template, store data fields, write script
// maintain state while running available builders so we
//     don't hang on any one builder
// maintain final concatenated output of all builders run on this test
// a test is finished well all of the configured builders have run
class Test {

    TestData _data = {};
    StringWriter _output = {};
    StringWriter _vOutput = {};

    int _status = T_INIT;
    Array[BuilderTestHarness] _harness = {};
    int _activeHarness = 0;

    String _isSkipped;

    void loadTemplate() {
        
        f := File(_data.fInfo.name, "r");
        if (!f.isValid()) {
            cout `file: $(_data.fInfo.name) could not be opened!\n`;
            _isSkipped = "unable to open";
            return;
        }
        
        // parse out sections
        String lineBuf, curSection;
        StringWriter dataBuf = {};
        headerPat := Regex('^%%(\\w+)%%$');
        while (lineBuf = f.nextLine()) {
            // look for section change
            m := headerPat.search(lineBuf);
            if (m) {
                if (curSection)
                    _data.sections[curSection] = dataBuf.createString();
                curSection = m.group(1);
                //cerr `debug: switching to group $curSection\n`;
                dataBuf = StringWriter();
            }
            else {
                // add line to current section
                dataBuf.write(lineBuf);
                if (curSection == 'TEST')
                    _data.desc = String(lineBuf, 0, lineBuf.size-1);
            }
        }
        if (curSection)
            _data.sections[curSection] = dataBuf.createString();

    }

    /// ensure test has required sections and that they contain valid data
    /// also check to see if we're skipping this test for some reason
    void checkTemplate() {        
        if (!_data.sections["FILE"]) {
            _isSkipped = "the template was missing a FILE section";
        }
    }

    void writeScript() {
        
        _data.scriptName = config.outDir.nameWithTrailing()+_data.fInfo.basename(true) + ".crk";
        
        //cout `writing: $outName\n`;
        
        out := File(_data.scriptName,"w");
        out.write(_data.sections["FILE"]);
        
    }

    void run() {
        
        if (_isSkipped) {
            cout `[$_data.fInfo]: $_isSkipped\n`;
            return;
        }
        
        cout `[$(_data.fInfo)]: $(_data.desc)\n`;

        writeScript();

        _status = T_RUNNING;

        // start initial harness
        _activeHarness = 0;
        _harness[_activeHarness].run();

    }

    int tick() {

        // if finished, get output, increase activeBuilder
        if (_harness[_activeHarness].tick() == T_FINISHED) {

                if (config.verbose)
                    _vOutput.write(_harness[_activeHarness]._vOutput.createString());
            _output.write(_harness[_activeHarness]._output.createString());

            _activeHarness++;
            if (_activeHarness < _harness.count()) {
                _harness[_activeHarness].run();
            }
            else {
                _status = T_FINISHED;
                cout `$(_vOutput.createString())\n`;
                cout `$(_output.createString())\n`;
            }

        }

        return _status;

    }

    String getResult() {
        /*
        for (r :in results) {
            if (!r.val.pass && (config.verbose || config.showDiff) && r.val.actual && r.val.expected) {
                cout `----$(r.key) Fail----\nExpected: [$(r.val.expected)] Actual: [$(r.val.actual)]\n------------\n`;
            }
        }
        */
        return "";
    }

    oper init(FileInfo info) {
        _data.fInfo = info;
        loadTemplate();
        checkTemplate();
        // setup test harnesses for this test, based on the builders
        // that have been selected
        for (b :in config.builders) {
            _harness.append((CrackBuilderDef.cast(b)).newTestHarness(_data));
        }
    }

    void _dump(Writer out) {
        for (t :in _data.sections)
            Formatter(out) `[$(t.key)]:\n$(t.val)`;
    }

    void writeTo(Writer out) {
        Formatter(out) `[$(_data.fInfo)]: $(_data.desc)\n`;
        //_dump(out);
    }

}

// handle command line
// find all tests
// handle queue of active tests
// decide which builders to run
class TestSuite {

    PriorityQueue[Test] _testList = {};
    Array[Test] _active = {};
    CmdOptions _options = {};
    
    void usage() {
        _options.printUsage(FStr() `Usage: $(argv[0]) -c <crack binary> [options]\n`);
        exit(1);
    }
    
    void scanForTests(Directory dir) {
    
        if (!dir.isValid()) {
            cerr `skipping invalid directory: $dir\n`;
            return;
        }
        
        cout `importing tests from $dir ... `;

        cnt := 0;
        // gather test files
        for (curFile :in dir.files()) {
            if (curFile.matches("*.crkt")) {
                cnt++;
                _testList.push(Test(curFile));
            }
        }

        cout `found $cnt\n`;
        
        // recurse to directories
        for (nextDir :in dir.dirs()) {
            scanForTests(nextDir);
        }

    }

    void runTests() {

        if (!config.outDir.isValid()) {
            cerr `invalid output directory: $(config.outDir)\n`;
            return;
        }
        
        cout `running $(config.jobs) concurrent tests with output in $(config.outDir)...\n`;

        bool cull(Test t) { return t.tick() != T_FINISHED; }

        Test cur;
        while (_testList.count()) {

            // check active for finished tests, remove
            _active.filter(cull);

            // add to active if active.count <= max
            while (_testList.count() &&
                   _active.count() < config.jobs) {
                cur = _testList.pop();
                _active.append(cur);
                cur.run();
            }

        }

    }

    oper init() {
        
        StringArray bDefStrings = {};
        for (i :in builderDefList) {
            bDefStrings.append(i.key);
        }
        String availBuilders = bDefStrings.join(',');

        _options.add("crackbin", "c", "Crack binary to test", "", CMD_STR);
        _options.add("help", "h", "Show usage", "f", CMD_BOOL);
        _options.add("verbose", "v", "Show verbose output", "f", CMD_BOOL);
        _options.add("jobs", "j", "Number of concurrent jobs", "10", CMD_INT);
        _options.add("testdir", "d", "Directory to search recursively for tests", "./tests", CMD_STR);
        _options.add("testfile", "f", "Single test template to execute", "", CMD_STR);
        _options.add("outdir", "o", "Directory to create output files", "./output", CMD_STR);
        _options.add("libpath", "l", "Add path to crack library path during test. May be colon seperated list.", "", CMD_STR);
        _options.add("builders", "b", "Builders to test, comma delimited list ["+availBuilders+"]",availBuilders, CMD_STR);
        _options.parse(argv);
                
        if (_options.getBool("help"))
            usage();

        // binary - required
        config.crackBin = _options.getString("crackbin");
        if (config.crackBin == "") {
            cerr `you must explicitly specify the crack binary via the -c option\n\n`;
            usage();
        }
        
        config.rootDir = Directory(_options.getString("testdir"), false);
        config.outDir = Directory(_options.getString("outdir"), false);

        config.libPath = _options.getString("libpath");
        config.verbose = _options.getBool("verbose");
        config.jobs = _options.getInt("jobs");
        config.showDiff = false;
        
        testFile := _options.getString("testfile");        
        if (testFile != "" && config.rootDir.isValid()) {
            // if specific file, clear directory
            config.rootDir = null;
            fi := FileInfo(testFile);
            if (!fi.exists()) {
                cerr `$testFile does not exist\n`;
                exit(1);
            }
            test := Test(fi);
            _testList.push(test);
            config.showDiff = true;
        }

        // verify, initialize builder defs
        builders := _options.getString("builders");
        clb := split(builders, ",");
        for (b :in clb) {
            if (bDefStrings.contains(b)) {
                config.builders.append(builderDefList[b]);
            }
            else {
                cout `invalid builder specified: $b`;
                exit(1);
            }
        }


        // banner
        cout `screen\n`;

        // check binary
        cfi := FileInfo(config.crackBin);
        if (!cfi.exists()) {
            cout `crack binary [$(config.crackBin)] not found\n`;
            exit(1);            
        }
        
        p := Process(config.crackBin+" --version");
        p.wait();
        String out = {};
        if (!p.failed())
            out = p.getStdOut();        
        if (p.failed() || p.getReturnCode() != 0) {
            cout `crack binary [$(config.crackBin)] failed to run, or unexpected result\n`;
            exit(1);
        }
        else if (out.size < 5 || out.slice(0,5) != "crack") {
            cout `crack binary [$(config.crackBin)] invalid version response: $(out.slice(0,5))\n`;
            exit(1);
        }
        else {
            cout `using binary: $out\n`;
        }
        
    }
    
    void run() {
        
        if (config.rootDir)
            scanForTests(config.rootDir);
        runTests();
        
    }

}

suite := TestSuite();
suite.run();
