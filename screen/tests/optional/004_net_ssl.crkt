%%TEST%%
crack.net.ssl
%%ARGS%%
%%FILE%%
import crack.logger setLogLevel, FATAL;
import crack.logger.ctx Log;
import crack.ext._ssl SSL;
import crack.fs makePath;
import crack.net InetAddress;
import crack.net.comm2 Comm, Connection, ConnectionFactory, NewConnection,
    UserHandler, WaiterFor;
import crack.io cerr;
import crack.io.readers LineReader;
import crack.lang AppendBuffer, Buffer;
import crack.random MersenneTwister;
import crack.runtime sleep;
import crack.net.ssl SSLConnection, SSLContext, SSLError;

@import crack.ann assert, impl;

setLogLevel(FATAL);

const ADDR := InetAddress(127, 0, 0, 1, 4433);

# The last client to connect.
Connection lastClient;

bool checkSSLUserData = false;

int getLen(Buffer buf) {
    int len = buf[0];
    if (len & 0x80) {
        if (buf.size < 2)
            return 256;
        len = (len << 8) & 0x7f00 | buf[1];
    }
    return len;
}

class ServerHandler @impl UserHandler {
    void process(Connection conn) {
        ssl := SSLConnection.get(conn);
        if (!ssl)
            cerr `SSL object not attached to connection.`;

        # Verify that user data got passed through correctly.
        if (checkSSLUserData && !(ssl.getUserData(0) is ADDR))
            cerr `User data not associated with SSL connection.`;

        len := getLen(conn.inBuf);
        if (conn.inBuf && conn.inBuf.size >= len) {
            conn.write(conn.inBuf);
            conn.inBuf.compact(len);
        }
    }

    void addResponder(Object responder) {}
    void terminate(Connection conn) {
        if (lastClient is conn)
            lastClient = null;
    }
}

class TestHandlerFactory @impl ConnectionFactory {
    Connection makeConnection(NewConnection conn) {
        lastClient = Connection(conn.log, ServerHandler());
        lastClient.processAllEvents = true;
        return lastClient;
    }
}

class ClientHandler @impl UserHandler {
    WaiterFor[String, int] __waiter;
    int terminated;

    void process(Connection conn) {
        @assert(SSLConnection.get(conn));
        len := getLen(conn.inBuf);
        if (conn.inBuf && conn.inBuf.size >= len) {
            if (__waiter)
                __waiter.setResult(
                    String(conn.inBuf, len, false)
                );
            else
                cerr `Unsolicited response!\n`;
            conn.inBuf.compact(len);
        }
    }

    void addResponder(Object responder) {
        __waiter = WaiterFor[String, int].cast(responder);
    }

    void terminate(Connection handler) {
        terminated += 1;
    }
}

comm := Comm(Log(null, null, cerr, cerr, cerr, 'ssltest'));
comm.start();
conn := SSLContext.make(makePath('test/test1.key'), makePath('test/test1.crt'),
                        comm
                        );

# Start the server.
comm.startServer(ADDR, conn.makeConnectionFactory(TestHandlerFactory()), true);

# Connect a client.
clientHandler := ClientHandler();
orgRc := clientHandler.refCount;
client := conn.connect(InetAddress(127, 0, 0, 1, 4433), clientHandler);
waiter := WaiterFor[String, int](0);
client.sendSync('\015hello world!', waiter);
@assert(waiter.getResult() == '\015hello world!');

if (true) {
    # Generate enough data to exceed the intermediate buffers.
    rand := MersenneTwister(12345678);
    data := AppendBuffer(8100 * 4);
    for (int i; i < 8100; ++i) {
        b := rand.get();
        data.append(byte(b >> 24));
        data.append(byte(b >> 16));
        data.append(byte(b >> 8));
        data.append(byte(b));
    }
    size := data.count() + 2;
    msg := String(1, byte((size >> 8) | 0x80)) +
           String(1, byte(size)) +
           String(data, true);

    waiter = WaiterFor[String, int](0);
    client.sendSync(msg, waiter);
    @assert(waiter.getResult() == msg);

    # Make sure we can get a message through after that.
    waiter = WaiterFor[String, int](0);
    msg = '\015hello world!';
    client.sendSync(msg, waiter);
    @assert(waiter.getResult() == msg);
}

client.closeSync();
client = null;
@assert(clientHandler.refCount == orgRc);
@assert(clientHandler.terminated == 1);

# Test PSK auth.
if (true) {

    import crack.runtime memcpy, strcpy;

    clientPSK := serverPSK := array[byte]![1, 2, 3, 4];

    uint clientCB(SSL ssl, byteptr hint, byteptr identity,
                  uint max_identity_length,
                  byteptr psk,
                  uint max_psk_length
                  ) {
        ident := 'identity';
        @assert(ident.size < max_psk_length);
        strcpy(identity, ident.buffer);

        @assert(max_psk_length >= 4);
        memcpy(psk, byteptr(clientPSK), 4);
        return 4;
    }

    uint serverCB(SSL ssl, byteptr identity, byteptr psk, uint max_psk_length) {
        @assert(String(identity) == 'identity');

        @assert(max_psk_length >= 4);
        memcpy(psk, byteptr(serverPSK), 4);
        ssl.setExData(0, ADDR);
        return 4;
    }

    checkSSLUserData = true;
    ctx := SSLContext.make(clientCB, serverCB, comm);
    const ADDR2 := InetAddress(127, 0, 0, 1, 4434);
    comm.startServer(ADDR2,
                     ctx.makeConnectionFactory(TestHandlerFactory()),
                     true
                     );

    client := ctx.connect(ADDR2, ClientHandler());
    waiter = WaiterFor[String, int](0);
    client.sendSync('\017secret message', waiter);
    @assert(waiter.getResult() == '\017secret message');
    client.closeSync();

    clientPSK = array[byte]![4, 3, 2, 1];
    try {
        client = ctx.connect(ADDR2, ClientHandler());
        @assert(false && "connection succeeded with invalid password.");
    } catch (SSLError ex) {
        # ok.
    }
}

comm.stop();

cerr `ok\n`;
%%EXPECT%%
ok
%%STDIN%%
